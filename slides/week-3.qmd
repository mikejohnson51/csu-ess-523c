---
title: "Week 3"
subtitle: "Predicates, Simplification & Tesselations"
format:
  revealjs: 
    smaller: false
    incremental: false
    logo: ../csu-rams-logo.png
    slide-number: c/t
    footer: "[ESS 523c: Environmental Data Science Applications: Water Resources](https://github.com/mikejohnson51/csu-ess-523c/)"
    include-before-body: header.html
    include-after-body: footer-annotations.html
    theme: [default, csu-css.scss]
    width: 1600
    height: 1000
    countIncrementalSlides: false
    title-slide-attributes:
      data-background-color: "#1E4D2B"
knitr:
  opts_chunk: 
    echo: true
    message: true
    collapse: true
    comment: "#>"
    out.width: "100%"
---

```{r, include = F}
library(sf)
library(tidyverse)
library(knitr)
library(AOI)
library(flipbookr)
library(units)

cities <-  readr::read_csv('../labs/data/uscities.csv') |>
  st_as_sf(coords = c("lng", "lat"), crs = 4326)  |> 
  select(city, state_name, population)

plot_tess = function(data, title){
  ggplot() + 
    geom_sf(data = data, fill = "white", col = "navy", size = .2) +   
    theme_void() +
    labs(title = title, caption = paste("This tesselation has:", nrow(data), "tiles" )) +
    theme(plot.title = element_text(hjust = .5, color =  "navy", face = "bold"))
}
```

# Last week

We learned about the SRS (Spatial Reference Systems)



- They can be **geographic** (3D, angular units)



  - Ellipsoid (squished sphere model)



  - geoid (mathematical model of gravitational field)
  

  
  - datum marks the relationship between the ellipsoid and geoid


    - can be local (NAD27)
    


    - can be global (WGS84, NAD83)
    

  
- SRS can be projected (x-y axis, measurement units (m), false origin)



  - All PCS are based on GCS
      

  
  - Projections seek to place the 3D earth on 2D
      

  
  - Does this by defining a plane that can be conic, cylindrical or planar
      

  
  - "unfolding to this plane" creates distortion of **shape**, **area**, **distance**, or **direction**
      

  
  - The distortion is greater from point/lines of tangency or secanacy 



# Measures (GEOS Measures)

- Measures are the questions we ask about the dimension of a geometry
    
  - How long is a line or polygon perimeter (unit)
  
  - What is the area of a polygon (unit^2^)
  
  - How far are two object from one another (unit)
      
- Measures come from the GEOS library
    
- Measures are in the **units** of the base projection
    
- Measures can be Euclidean (PCS) or geodesic (GSC)

  - geodesic (Great Circle) distances can be more accurate by eliminating distortion

  - but are much slower to calculate

## For example ...

```{r}
usa <- st_cast(st_union(aoi_get(state = "conus")), "MULTILINESTRING")

nrow(cities)
```

<br>

```{r,eval = FALSE}
# Great Circle Distance in GCS
system.time({x <- st_distance(usa, cities)})
# user      system elapsed 
# 103.560   1.390  117.128 

# Euclidean Distance on PCS
system.time({x <- st_distance(usa, cities, which = "Euclidean")})
# user    system  elapsed 
# 2.422   0.019   2.494 
```

## Units

When possible measure operations report results with a units appropriate for the CRS:

```{r}
co <- st_read("data/co.shp")
a <- st_area(co[1,])
attributes(a) |> unlist()
```

The **units** package can be used to convert between units:

```{r}
units::set_units(a, km^2) # result in square kilometers
units::set_units(a, ha) # result in hectares
```

and the results can be stripped of their attributes for cases where numeric values are needed (e.g. math operators and ggplot):

```{r}
as.numeric(a)
```

## Topologic Diminsion

A **POINT** is shape with a dimension of 0 that occupies a single location in coordinate space.

```{r}
# POINT defined as numeric vector
(st_dimension(st_point(c(0,1))))
```


A **LINESTRING** is shape that has a dimension of 1 (length)

```{r}
# LINESTRING defined by matrix
(st_dimension(st_linestring(matrix(1:4, nrow = 2))))
```

A **POLYGON** is surface stored as a list of its exterior and interior rings. It has a dimension of 2. (area)

```{r}
# POLYGON defined by LIST (interior and exterior rings)
(st_dimension(st_polygon(list(matrix(c(1:4, 1,2), nrow = 3, byrow = TRUE)))))
```

# Predicates

## Geometric Interiors, Boundaries and Exteriors

All geometries have interior, boundary and exterior regions.

The terms `interior` and `boundary` are used in the context of algebraic topology and manifold theory and **not** general topology

The OGC has define these states for the common geometry types in the simple features standard:

| Dimension 	| Geometry Type 	| Interior (I) 	| Boundary (B) 	|
|:-	|:-	|:-	|:-	|
| Point, MultiPoint             | 0   	| Point, Points                                              	| Empty            |  
| LineString, Line              | 1   	| Points that are left when the boundary points are removed. 	| Two end points.  |   	
| Polygon                       | 2   	| Points within the rings.                                   	| Set of rings.    |   	
  
## Interior, Boundary and Exterior: POINTS

```{r fig.height=6, fig.width=10, echo=FALSE, message=FALSE, fig.align='center'}

g = st_bbox(c(xmin = 0, xmax = 10, ymax = 6, ymin = 0)) |> 
  st_as_sfc() |> 
  st_make_grid(cellsize = 1)

point = st_sfc(st_point(c(5,3)))


p0 = ggplot() + 
  geom_sf(data = g, fill = "white") + 
  geom_sf(data = point, col = "red", size  = 3) + 
  theme_void() + 
  labs(title = "POINT")

p1 = ggplot() + 
  geom_sf(data = g, fill = "white") + 
  geom_sf(data = point, col = "red", size  = 3) + 
  theme_void() + 
  labs(title = "Interior (POINT)")

p2 = ggplot() + 
  geom_sf(data = g, fill = "white") + 
  geom_sf(data = point, col = "navy", size  = 3) + 
  theme_void() + 
  labs(title = "Boundary (POINT)")

p3 = ggplot() + 
  geom_sf(data = g, fill = "orange", alpha = .5) + 
  geom_sf(data = point, col = "red", size  = 3) + 
  theme_void() + 
  labs(title = "Exterior (POINT)")

gridExtra::grid.arrange(p1,p0,p2,p3, nrow = 1)
```

## Interior, Boundary and Exterior: LINESTRING

```{r fig.height=6, fig.width=10, echo=FALSE, message=FALSE, fig.align='center'}
l0 = ggplot() + 
  geom_sf(data = g, fill = "white") + 
  geom_segment(aes(x = 2, y = 2, xend = 8, yend = 4 ), col = "red", size = 2) +
  theme_void() + 
  labs(title = "LINESTRING")

l1 = ggplot() + 
  geom_sf(data = g, fill = "white") + 
  geom_point(aes(x = 2, y = 2), size = 3, col = "navy") +
  geom_point(aes(x = 8, y = 4), size = 3, col = "navy") + 
  geom_segment(aes(x = 2, y = 2, xend = 8, yend = 4), col = "red") +
  theme_void() + 
  labs(title = "Interior (LINESTRING)")

l2 = ggplot() + 
  geom_sf(data = g, fill = "white") + 
  geom_point(aes(x = 2, y = 2), size = 3, col = "red") +
  geom_point(aes(x = 8, y = 4), size = 3, col = "red") + 
  theme_void() + 
  labs(title = "Boundary (LINESTRING)")

l3 = ggplot() + 
  geom_sf(data = g, fill = "orange", alpha = .5) + 
  geom_point(aes(x = 2, y = 2), size = 3, col = "navy") +
  geom_point(aes(x = 8, y = 4), size = 3, col = "navy") + 
  geom_segment(aes(x = 2, y = 2, xend = 8, yend = 4), col = "red") +
  theme_void() + 
  labs(title = "Exterior (LINESTRING)")

gridExtra::grid.arrange(l0,l1,l2,l3, nrow = 1)
```

## Interior, Boundary and Exterior: POLYGON

```{r fig.height=6, fig.width=10, echo=FALSE, message=FALSE, fig.align='center'}
pg = g[c(23:28, 33:38)] 

area = st_union(pg) 

border = st_cast(area, "LINESTRING")

pg0 = ggplot() + 
  geom_sf(data = g, fill = "white") + 
  geom_sf(data = area, fill = "red")+
  geom_sf(data = border,  color = "navy", size = 3)+
  theme_void() + 
  labs(title = "POLYGON")

pg1 = ggplot() + 
  geom_sf(data = g, fill = "white") + 
  geom_sf(data = area, fill = "red", alpha = .5)+
  theme_void() + 
  labs(title = "Interior (POLYGON)")

pg2 = ggplot() + 
  geom_sf(data = g, fill = "white") + 
  geom_sf(data = border,  color = "red", size = 3)+
  theme_void() + 
  labs(title = "Boundary (POLYGON)")

pg3 = ggplot() + 
  geom_sf(data = g, fill = "orange", alpha = .5) + 
  geom_sf(data = pg,  fill = "white")+
  theme_void() + 
  labs(title = "Exterior (POLYGON)")

gridExtra::grid.arrange(pg0,pg1,pg2,pg3, nrow = 1)
```

## Summary

```{r fig.height=7, fig.width=10, echo=FALSE, message=FALSE, fig.align='center'}
fin  = gridExtra::grid.arrange(p0,p1,p2,p3,
                        l0,l1,l2,l3,
                        pg0,pg1,pg2,pg3,
                        nrow = 3)

ggsave(fin, filename = "images/12-int-ext-bound.png", width = 10, height = 7)
```

## Predicates

In the following, we are interested in the resulting geometry that occurs when 2 geometries are overlaid...

## Overlap is a POINT: 0D

```{r, echo = F, fig.width=10, fig.height=2, fig.align='center'}
geom1 = g[c(12:16, 22:26)] |> 
  st_union()
geom2 = g[c(37:39, 47:49)]  |> st_union()

g1 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  theme_void()

g2 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom2, fill = "blue")+
  theme_void()

g3 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  geom_sf(data = geom2, fill = "blue")+
  theme_void()

g4 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_point(aes(x = 7,y = 3)) +
  theme_void()

gridExtra::grid.arrange(g1,g2,g3,g4, nrow = 1)
```

```{r, echo = F, fig.width=10, fig.height=2, fig.align='center'}
geom1 = g[c(12:16, 22:26, 32:36)] |> 
  st_union()
geom2 = st_linestring(matrix(c(4,6,9,1), byrow = TRUE, nrow = 2)) |> 
  st_sfc()

g1 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  theme_void()

g2 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom2, color = "blue", size = 2)+
  theme_void()

g3 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  geom_sf(data = geom2, color = "blue", size = 2)+
  theme_void()

g4 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_point(aes(x = 6,y = 4)) +
  theme_void()

gridExtra::grid.arrange(g1,g2,g3,g4, nrow = 1)
```

```{r, echo = F, fig.width=10, fig.height=2, fig.align='center'}
geom1 = g[c(12:16, 22:26, 32:36)] |> 
  st_union()

geom2 = st_point(c(5,4)) |> 
  st_sfc()

g1 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  theme_void()

g2 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom2, color = "blue", size = 2)+
  theme_void()

g3 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  geom_sf(data = geom2, color = "blue", size = 2)+
  theme_void()

g4 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom2, size = 2) +
  theme_void()

gridExtra::grid.arrange(g1,g2,g3,g4, nrow = 1)
```

## Overlap is a LINESTRING: 1D

```{r, echo = F, fig.width=10, fig.height=2, fig.align='center'}
geom1 = g[c(32:36, 42:46)] |> 
  st_union()
geom2 = st_linestring(matrix(c(6,1,2,5), byrow = TRUE, nrow = 2)) |> 
  st_sfc()

g1 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  theme_void()

g2 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom2, color = "blue", size = 2)+
  theme_void()

g3 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  geom_sf(data = geom2, color = "blue", size = 2)+
  theme_void()

g4 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_segment(aes(x=4,xend = 2,y =3, yend = 5), size = 2) +
  theme_void()

gridExtra::grid.arrange(g1,g2,g3,g4, nrow = 1)
```

```{r, echo = F, fig.width=10, fig.height=2, fig.align='center'}
geom1 = g[c(12:17, 22:27)] |> 
  st_union()
geom2 = g[c(35:39, 45:49)] |> 
  st_union()

g1 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  theme_void()

g2 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom2, fill = "blue")+
  theme_void()

g3 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  geom_sf(data = geom2, fill = "blue")+
  theme_void()

g4 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_segment(aes(x=4,xend = 7,y =3, yend = 3), size = 2) +
  theme_void()

gridExtra::grid.arrange(g1,g2,g3,g4, nrow = 1)
```

```{r, echo = F, fig.width=10, fig.height=2, fig.align='center'}
geom1 = st_linestring(matrix(c(2,3,8,3), byrow = TRUE, nrow = 2)) |> 
  st_sfc()

geom2 = st_linestring(matrix(c(4,3,7,3), byrow = TRUE, nrow = 2)) |> 
  st_sfc()

g1 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, color = "orange",size = 2)+
  theme_void()

g2 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom2, color = "blue", size = 2)+
  theme_void()

g3 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, color = "orange", size = 2)+
  geom_sf(data = geom2, color = "blue", size = 2)+
  theme_void()

g4 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom2, size = 2) +
  theme_void()

gridExtra::grid.arrange(g1,g2,g3,g4, nrow = 1)
```

## Overlap is a POLYGON: 2D

```{r, echo = F, fig.width=10, fig.height=2, fig.align='center'}
geom1 = g[c(23:27, 33:37)] |> 
  st_union()
geom2 = g[c(36:39, 46:49)] |> 
  st_union()

g1 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  theme_void()

g2 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom2, fill = "blue")+
  theme_void()

g3 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  geom_sf(data = geom2, fill = "blue")+
  theme_void()

g4 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = st_intersection(geom1,geom2), fill = "black") +
  theme_void()

gridExtra::grid.arrange(g1,g2,g3,g4, nrow = 1)
```

```{r, echo = F, fig.width=10, fig.height=2, fig.align='center'}
geom1 = g[c(12:19,  22:29, 32:39, 42:49)] |> 
  st_union()
geom2 = g[c(23:27, 33:37)] |> 
  st_union()

g1 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  theme_void()

g2 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom2, fill = "blue")+
  theme_void()

g3 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  geom_sf(data = geom2, fill = "blue")+
  theme_void()

g4 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = st_intersection(geom1,geom2), fill = "black") +
  theme_void()

gridExtra::grid.arrange(g1,g2,g3,g4, nrow = 1)
```

```{r, echo = F, fig.width=10, fig.height=2, fig.align='center'}
geom1 = g[c(23:27, 33:37)] |> 
  st_union()
geom2 = g[c(16:19, 26:29,36:39,46:49)] |> 
  st_union()

g1 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  theme_void()

g2 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom2, fill = "blue")+
  theme_void()

g3 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  geom_sf(data = geom2, fill = "blue")+
  theme_void()

g4 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = st_intersection(geom1,geom2), fill = "black") +
  theme_void()

gridExtra::grid.arrange(g1,g2,g3,g4, nrow = 1)
```

## No Overlap = FALSE

```{r, echo = F, fig.width=10, fig.height=2, fig.align='center'}
geom1 = g[c(23:25, 33:35)] |> 
  st_union()
geom2 = g[c(37:39, 47:49)] |> 
  st_union()

g1 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  theme_void()

g2 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom2, fill = "blue")+
  theme_void()

g3 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = geom1, fill = "orange")+
  geom_sf(data = geom2, fill = "blue")+
  theme_void()

g4 = ggplot() +
  geom_sf(data = g, fill = "white") +
  geom_sf(data = st_intersection(geom1,geom2), fill = "black") +
  theme_void()

gridExtra::grid.arrange(g1,g2,g3,g4, nrow = 1)
```


## Dimensionally Extended 9-Intersection Model

- The DE-9IM is a **topological** model and (standard) used to describe the spatial relations of two geometries 

- Used in geometry, point-set topology, geospatial topology

- The **DE-9IM** _matrix_ provides a way to classify geometry relations using the set **{0,1,2,F}** or **{T,F}**

- With a **{T,F}** matrix domain, there are 512 possible relations that can be grouped into binary classification schemes. 

- About 10 of these, have been given a common name such as _intersects_, _touches_, and _within_. 

- When testing two geometries against a scheme, the result is a spatial _predicate_ named by the scheme.

- Provides the primary basis for queries and assertions in GIS and spatial databases (PostGIS).

## The Matrix Model

The **DE-9IM** matrix is based on a 3x3 intersection matrix:

```{r, fig.align='center', out.width = "50%", echo = FALSE}
knitr::include_graphics('images/12-de-9Im-matrix.png')
```

Where: 

  - **dim** is the dimension of the intersection and
  - I is the interior
  - B is the boundary
  - E is the exterior 

. . . 

Empty sets are denoted as **F** 

non-empty sets are denoted with the maximum dimension of the intersection *{0,1,2}*

## 

A simpler (binary) version of this matrix can be created by mapping all non-empty intersections {0,1,2} to TRUE.

![](images/12-de-9Im-matrix-simple.svg)

Where `II` would state: "Does the Interior of "a" overlaps with the Interior of "b" in a way that produces a point (0), line (1), or polygon (2)"

Where `IB` would state: "Does the Interior of "a" overlap with the Boundary of "b" in a way that produces a point (0), line (1), or polygon (2)"

Both matrix forms:
  - dimensional {0,1,2,F}
  - Boolean {T,F}
  
. . . 

Can be serialize as a "DE-9IM string code" representing the matrix in a single string element (standardized format for data interchange)

The OGC has standardized the typical spatial predicates (Contains, Crosses, Intersects, Touches, etc.) as *Boolean* functions, and the DE-9IM model as a function that returns the DE-9IM code, with domain of {0,1,2,F}

## Illustration

```{r, fig.align='center', out.width = "50%", echo = FALSE}
knitr::include_graphics('images/12-de-91m-figure.png')
```

Reading from left-to-right and top-to-bottom, the DE-9IM(a,b) string code is '212101212'

## Spatial Relations in R

- Geometry X is a 3 feature polygon colored in red
- Geometry Y is a 4 feature polygon colored in blue

::: columns
::: {.column-width = "50%"}
```{r, echo = FALSE}
#| out.width: '50%'
b0 = st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))))
b1 = b0 + 2
b2 = b0 + c(-0.2, 2)
x = st_sfc(b0, b1, b2)
a0 = b0 * 0.8
a1 = a0 * 0.5 + c(2, 0.7)
a2 = a0 + 1
a3 = b0 * 0.5 + c(2, -0.5)
y = st_sfc(a0,a1,a2,a3)
plot(x, border = 'red')
plot(y, border = 'blue', add = TRUE)
```
::: {.column-width = "50%"}
:::
```{r}
st_relate(x,y)
st_relate(x,x)
st_relate(y,y)
```
:::
:::

## Named Predicates {.smaller}

- "named spatial predicates" have been defined for some common relations.

- A few functions can be derived (expressed by masks) from DE-9IM include (* = wildcard):

| Predicate 	| DE-9IM String Code 	| Description 	|
|:-	|:-	|:-	|
| **Intersects** 	| `T*F**FFF*` 	| "Two geometries intersect if they share any portion of space" 	|
| **Overlaps** 	| `T*F**FFF*` 	| "Two geometries overlap if they share some but not all of the same space" 	|
| **Equals** 	| `T*F**FFF*` 	| "Two geometries are topologically equal if their interiors intersect and no part of the interior or boundary of one geometry intersects the exterior of the other" 	|
| **Disjoint** 	| `FF*FF*****` 	| "Two geometries are disjoint: they have no point in common. They form a set of disconnected geometries." 	|
| **Touches** 	| `FT*******` | `F**T*****` | `F***T****` 	| "Two geometries touch if they have at least one point in common, but their interiors do not intersect." 	|
| **Contains** 	| `T*****FF**` 	| "A contains B: geometry B lies in A, and the interiors intersect" 	|
| **Covers** 	| `T*****FF*` | `*T****FF*` | `***T**FF*` | `****T*FF*` 	| "A covers B: geometry B lies in A." 	|
| **Within** 	| `*T*****FF*` | `**T****FF*` | `***T**FF*` | `****T*FF*` 	| "A within B: geometry A lies in B." 	|
| **Covered by** 	| `*T*****FF*` | `**T****FF*` | `***T**FF*` | `****T*FF*` 	| "A covered by B: geometry A lies in B." 	|

## Binary Predicates

- Collectively, predicates define the type of relationship each 2D object has with another.

- Of the ~ 512 unique relationships offered by the DE-9IM models a selection of ~ 10 have been named.

- These are include in PostGIS/GEOS and are made accessible via R sf

```{r, fig.align='center', fout.width = "50%", echo = FALSE}
knitr::include_graphics('images/13-sf-binary.png')
```

## Named predicates in R 

- `sf` provides a set of functions that implement the DE-9IM model and named predicates. Each of these can return either a *sparse* or *dense* matrix.

#### *sparse* matrix

```{r}
st_intersects(x,y)
```

#### *dense* matrix

```{r}
st_intersects(x, y, sparse = FALSE)

st_disjoint(x, y, sparse = FALSE)

st_touches(x, y, sparse = FALSE)

st_within(x, y, sparse = FALSE)
```

## st_relates vs. predicate calls...

```{r, message = F, warning = F}
states = filter(aoi_get(state = "all"), state_abbr %in% c("WA", "OR", "MT", "ID")) |>
  select(name)

wa = filter(states, name == "Washington")
```

::: columns
::: {column.wdith = "50%"}
```{r}
#| out.width: '50%'
plot(states$geometry)
```
:::
::: {column.wdith = "50%"}
```{r, message = F, warning = F}
(mutate(states, 
        deim9 = st_relate(states, wa),
        touch = st_touches(states, wa, sparse = F)))
```
:::
:::

# So... 

- binary predicates return conditional _{T,F}_ relations based on predefined masks of the DE-9IM strings

- Up to this point in class we have been using Boolean _{T,F}_ masks to filter data.frames by columns:

```{r}
fruits = c("apple", "orange", "lemon", "watermelon")
```

```{r}
fruits == "apple"
```

```{r}
fruits %in% c("apple", "lemon")
```

## Filtering on data.frames

- We have used `dplyr::filter` to  subset a data frame, retaining all rows that satisfy a `boolean` condition. 

::: columns
::: {column.wdith = "50%"}
```{r}
mutate(states, equalsWA = (name == "Washington")) |> 
  st_drop_geometry()
```
:::
::: {column.wdith = "50%"}
```{r}
filter(states, name == "Washington")
```
:::
:::

## Spatial Filtering
 
- We can filter spatially, use `st_filter` as the function call

- Here the `boolean` condition is not passed (e.g. name == WA)

- But instead, is defined by a spatial predicate

- The default is `st_intersects` but can be changed with the `.predicate` argument:

::: columns
::: {.column width="50%"}
```{r}
mutate(states, 
       touch = st_touches(states, wa, sparse = FALSE)) 
```
:::
::: {.column width="50%"}
```{r}
st_filter(states, wa, .predicate = st_touches) 
```
:::
:::

## Result 

```{r, message = FALSE, echo = TRUE, fig.width=6, fig.height=6,fig.align='center'}
ggplot(states) + 
  geom_sf() + 
  geom_sf(data = wa, fill = "blue", alpha = .3) +
  geom_sf(data = st_filter(states, wa, .predicate = st_touches), fill = "red", alpha = .5) + 
  theme_void()
```

## Distance Example (additional parameter)

```{r, message = FALSE }
cities = read_csv("../labs/data/uscities.csv") |> 
  st_as_sf(coords = c("lng", "lat"), crs = 4326) |> 
  select(city, population, state_name) |> 
  st_transform(5070)
```

```{r}
st_filter(cities, 
          filter(cities, city == "Fort Collins"), 
          .predicate = st_is_within_distance, 10000) 
```

# Spatial Data Science

- Filtering is a nice way to reduce the dimensions of a **single** dataset

- Often "*... one table is not enough... *"

- In these cases we want to combine - or **join** -  data 
 

# Spatial Joining

- Joining two non-spatial datasets relies on a shared _key_  that uniquely identifies each record in a table

```{r, fig.align='center', fig.height = 5, echo = FALSE}
knitr::include_graphics('images/07-joins.png')
```

- Spatially joining data relies on shared _geographic relations_ rather then a shared _key_

- Like filter, these relations can be defined by a **predicate**

- As with tabular data, mutating joins *add* data to the target object (x) from a source object (y).

## st_join

- In `sf` `st_join` provides this joining capacity

- By default, `st_join` performs a _left_ join (Returns all records from x, and the matched records from y)

```{r, fig.align='center', out.width = "25%", echo = FALSE}
knitr::include_graphics('images/13-left-join.png')
```

- It can also do inner joins by setting `left = FALSE`. 

```{r, fig.align='center', out.width = "25%", echo = FALSE}
knitr::include_graphics('images/13-inner-join.png')
```

- The default predicate for `st_join` (and `st_filter`) is `st_intersects`

- This can be changed with the join argument (see `?st_join` for details).

# Every Starbucks in the World

What county has the most Starbucks in each state?

```{r, message= FALSE, warning = FALSE}
(starbucks = readr::read_csv('../labs/data/directory.csv') |> 
  filter(!is.na(Latitude), Country == "US") |> 
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) |> 
  st_transform(5070))
```

```{r}
counties = aoi_get(state = "conus", county = "all") |> 
  st_transform(5070) |> 
  select(name, state_name)
```

## 

```{r,message=FALSE, fig.align = 'center'}
topSB <- st_join(counties, starbucks) |> 
  group_by(name, state_name) |> 
  summarise(n = n()) |> 
  group_by(state_name) |> 
  slice_max(n, n = 1) |> 
  ungroup()
```

```{r, echo  = F, fig.height=6, fig.align="center"}
ggplot() + 
  geom_sf(data = counties, size = .05, fill = "white") + 
  geom_sf(data = topSB, aes(fill = n), size = .1) + 
  scale_fill_viridis_c() + 
  theme_void() + 
  theme(legend.position = 'bottom') + 
  labs(title = "County with Most Starbucks by State",
       fill = "Number of stores: ")
```

## 

- Neither _joining_ nor _filtering_ spatially alter the underlying geometry of the features
- In cases where we seek to alter a geometry based on another, we need clipping methods

## Clipping 

- Clipping is a form of subsetting that involves changing the geometry of at least some features.

- Clipping can only apply to features more complex than points: (lines, polygons and their ‘multi’ equivalents). 

```{r, fig.align='center', fig.height = 5, echo = FALSE}
knitr::include_graphics('images/13-clipping.png')
```

## Spatial Subsetting

- By default the data.frame subsetting methods we've seen (e.g `[,]`) implements `st_intersection`

```{r, fig.align='center', fig.height=6}
wa = st_transform(wa, 5070)
wa_starbucks = starbucks[wa,] #<<

ggplot() + geom_sf(data = wa) + geom_sf(data = wa_starbucks) + theme_void()
```

# Simplification

# Computational Complexity

- In all the cases we have looked at, the number of `POINT` (e.g geometries, nodes, or vertices) define the complexity of the predicate or the clip

- Computational needs increase with the number of POINTS / NODES / VERTICES

- **Simplification** is a process for generalization  vector objects (lines and polygons) 

- Another reason for simplifying objects is to reduce the amount of memory, disk space and network bandwidth they consume

- Other times the level of detail captured in a geometry is either not needed, or, even counter productive the the scale/purpose of an analysis

- If you are cropping features to a national border, how much detail do you need? The more points in your border, the long the clip operation will take....

##

In cases where we want to reduce the complexity in a geometry we can use simplification algorithms

The most common algorithms are Ramer–Douglas–Peucker and Visvalingam-Whyatt.

## Ramer–Douglas–Peucker

- Mark the `first` and `last` points as kept

- Find the point, `p` that is the farthest from the first-last line segment. If there are no points between first and last we are done (the base case)

- If `p` is closer than `tolerance` units to the line segment then everything between first and last can be discarded

- Otherwise, mark p as kept and repeat steps 1-4 using the points between first and p and between p and last (the call to recursion)

```{r, fig.align='center', out.width = "100%", echo = FALSE}
knitr::include_graphics('images/13-douglas-peucker-animated.gif')
```

## st_simplify

```{r, fig.align='center', out.width = "90%", echo = FALSE}
knitr::include_graphics('images/13-postgis-st-simplify.png')
```

## st_simplify

-  `sf` provides `st_simplify`, which uses the GEOS implementation of the Douglas-Peucker algorithm to reduce the vertex count. 

- `st_simplify` uses the `dTolerance` to control the level of generalization in map units (see Douglas and Peucker 1973 for details). 

```{r, fig.align='center', out.width = "50%", echo = FALSE}
knitr::include_graphics('images/13-r-st-simplify.png')
```

##

```{r}
usa = aoi_get(state = "conus") |> 
  st_union() |> 
  st_transform(5070)

usa1000   = st_simplify(usa, dTolerance = 10000)
usa10000  = st_simplify(usa, dTolerance = 100000)
usa100000 = st_simplify(usa, dTolerance = 1000000)
```

```{r fig.height=4, fig.width=12, echo=FALSE, message=FALSE, fig.align='center'}
g1 = ggplot(usa) + 
  geom_sf() + 
  labs(title = paste(mapview::npts(usa), 'points'),
       caption = "dTolerance = 0") +
  theme_void()

g2 = ggplot(usa1000) + 
  geom_sf() + 
  labs(title = paste(mapview::npts(usa1000), 'points'),
       caption = "dTolerance = 1,000") +
  theme_void()

g3 = ggplot(usa10000) + 
  geom_sf() + 
  labs(title = paste(mapview::npts(usa10000), 'points'),
       caption = "dTolerance = 10,000") +
  theme_void()

g4 = ggplot(usa100000) + 
  geom_sf() + 
  labs(title = paste(mapview::npts(usa100000), 'points'),
       caption = paste("dTolerance = 100,000\n",
                  st_length(st_cast(usa1000, "MULTILINESTRING")))) +
  theme_void()

gridExtra::grid.arrange(g1,g2,g3,g4, nrow = 1)
```

## 

- A limitation with Douglas-Peucker (therefore st_simplify) is that it simplifies objects on a per-geometry basis. 

- This means the ‘topology’ is lost, resulting in overlapping and disconnected geometries. 

```{r}
states = st_transform(states, 5070)
simp_states   = st_simplify(states, dTolerance = 20000)
plot(simp_states$geometry)
```

## Visvalingam

- The Visvalingam algorithm overcomes some limitations of the Douglas-Peucker algorithm (Visvalingam and Whyatt 1993).
- it progressively removes points with the least-perceptible change. 
- Simplification often allows the elimination of 95% or more points while retaining sufficient detail for visualization and often analysis

```{r, fig.align='center', out.width = "50%", echo = FALSE}
knitr::include_graphics('images/13-ms-simplify.png')
```

## rmapshaper

In R, the `rmapshaper` package implements the Visvalingam algorithm in the `ms_simplify` function. 

- The `ms_simplify` function is a wrapper around the `mapshaper` JavaScript library (created by lead viz experts at the NYT)

```{r}
library(rmapshaper)

usa10 = ms_simplify(usa, keep = .1)
usa5  = ms_simplify(usa, keep = .05)
usa1  = ms_simplify(usa, keep = .01)
```

```{r fig.height=4, fig.width=12, echo=FALSE, message=FALSE, fig.align='center'}

g1 = ggplot(usa) + 
  geom_sf() + 
  labs(title = paste(mapview::npts(usa), 'points'),
       caption = "keep = 1") +
  theme_void()

g2 = ggplot(usa10) + 
  geom_sf() + 
  labs(title = paste(mapview::npts(usa10), 'points'),
       caption = "keep = .1 (10%)") +
  theme_void()

g3 = ggplot(usa5) + 
  geom_sf() + 
  labs(title = paste(mapview::npts(usa5), 'points'),
       caption = "keep = .05 (5%)") +
  theme_void()

g4 = ggplot(usa1) + 
  geom_sf() + 
  labs(title = paste(mapview::npts(usa1), 'points'),
       caption = "keep = .01 (1%)") +
  theme_void()

gridExtra::grid.arrange(g1,g2,g3,g4, nrow = 1)
```

##

```{r}
states = st_transform(states, 5070)
simp_states   = ms_simplify(states, keep = .05)
plot(simp_states$geometry)
```

##

In all cases, the number of points in a geometry can be calculated with `mapview::npts()`

```{r}
states = st_transform(states, 5070)
simp_states_st   = st_simplify(states, dTolerance = 20000)
simp_states_ms   = ms_simplify(states, keep = .05)

mapview::npts(states)
mapview::npts(simp_states_st)
mapview::npts(simp_states_ms)
```

# Tesselation

- So far we have spent the last few days looking at simple feature objects

- Where a feature as a geometry define by a set of structured POINT(s) 

- These points have precision and define location ({X Y CRS})

- The geometry defines a bounds: either 0D, 1D or 2D 

- Each object is therefore bounded to those geometries implying a level of exactness.

## Core Concepts of Spatial Data: ([Kuhn 2012](https://www.tandfonline.com/doi/full/10.1080/13658816.2012.722637))

```{r, fig.align='center', fig.height = 5, echo = FALSE}
knitr::include_graphics('images/15-cc.png')
```

## Core Concepts of Spatial Data: ([Kuhn 2012](https://www.tandfonline.com/doi/full/10.1080/13658816.2012.722637))

- **One Base Concept**: Location

- **Four Content Concepts**: Field, Object, Network, Event

- **Two Quality Concepts**: Granularity, Accuracy

## Core Concepts of Spatial Data: ([Kuhn 2012](https://www.tandfonline.com/doi/full/10.1080/13658816.2012.722637))

- **One Base Concept**: Location (*coordinates*)

- **Four Content Concepts**: Field (*raster*), Object (*simple feature*), <del>Network</del>, <del>Event</del>

- **Two Quality Concepts**: Granularity (*simplification*), Accuracy (*taken for granted*)


## Object View

- Objects describe *individuals* that have an identity (id) as well as spatial, temporal, and thematic properties. 

- Answers questions about _properties_ and _relations_ of objects. 

- Results from fixing theme, controlling time, and measuring space. 

- Features, such as surfaces, depend on objects (but are also objects)

## Object View

- Object implies boundedness

    - boundaries may not be known or even knowable, but have limits. 

- Crude examples of such limits are the minimal bounding boxes used for indexing and querying objects in databases. 

- Many objects (particularly natural ones) do not have crisp boundaries (watersheds) 

- Differences between spatial information from multiple sources are often caused by more or less arbitrary delineations through context-dependent boundaries. 

- Many questions about objects and features can be answered without boundaries, using simple point representations (centroids) with thematic _attributes_.


## Field View

- Fields describe phenomena that have a scalar or vector attribute everywhere in a space of interest 

  - for example, air temperatures, rainfall, elevation, land cover 
  
- Field information answers the question **what is here?**, where here can be anywhere in the space considered. 

- Field-based spatial information can also represent attributes that are computed rather than measured, such as probabilities or densities.

```{r, fig.align='center', fig.height = 3, echo = FALSE}
knitr::include_graphics('images/15-prob-snow-christmas.jpg')
```

Together, fields and objects are  the two fundamental ways of structuring spatial information. 

## Objects can provide coverage:

- Both objects and fields can cover space continuously - the primary difference is that objects prescribe bounds.

  - Counties are one form of object that covers the USA seamlessly

  - State objects are another ...

# Object Coverages

## LANDSAT Path Row

- Serves tiles based on a path/row index

```{r, echo = FALSE, fig.align='center', fig.width=10}
ls = read_sf('../labs/data/CONUS_ARD_grid/conus_ard_grid.shp')

states = AOI::aoi_get(state = "conus") |> 
  st_transform(st_crs(ls))

csu = AOI::geocode("Colorado State Universiy", pt = TRUE) |> 
  st_transform(st_crs(ls))

ggplot() + 
  geom_sf(data = states, col = NA, alpha = .95) + 
  geom_sf(data = ls, fill = NA) + 
  geom_sf(data = csu, col = "darkred", aes(label = request)) + 
  ggrepel::geom_label_repel(
    data = csu,
    aes(label = request, geometry = geometry),
    stat = "sf_coordinates"
  ) +
  theme_void()+ 
  labs(title = "LANDSAT Path/row")
```


## MODIS Sinisoial Grid

- Serves tiles based on a path/row index

```{r, echo = FALSE, fig.align='center', fig.width=10}
ls = read_sf('../labs/data/modis_grid/modis_sinusoidal_grid_world.shp') |> 
  st_set_crs('+proj=sinu +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs')

states = rnaturalearth::ne_countries(returnclass = "sf") |> st_transform(st_crs(ls))

csu = csu |> 
  st_transform(st_crs(ls))

ggplot() + 
  geom_sf(data = states, col = NA, fill = "gray",alpha = 1) + 
  geom_sf(data = ls, fill = NA) + 
  geom_sf(data = csu, col = "darkred", aes(label = request)) + 
  ggrepel::geom_label_repel(
    data = csu,
    aes(label = request, geometry = geometry),
    stat = "sf_coordinates"
  ) +
  theme_void()+ 
  labs(title = "MODIS Path/row")
```

## [Uber Hex Addressing](https://eng.uber.com/h3/)

- Breaks the world into Hexagons...\

<br>

::: columns
::: {.column width="50%"}

```{r}
#| echo: false
#| out.width: "100%"
knitr::include_graphics('images/15-uber-h3.jpeg')
```

:::
::: {.column width="50%"}

```{r}
#| echo: false
#| out.width: "100%"
knitr::include_graphics('images/15-uber-h3-zoom.jpeg')
```

:::
:::

## [what3word](https://what3words.com/switched.mandates.apple)

- Breaks the world into 3m grids encoded with unique 3 word strings

```{r, fig.align='center', fig.width = 7, echo = FALSE}
knitr::include_graphics('images/15-what3words.png')
```

## [Map Tiles / slippy maps / Pyramids](https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames)

- Use XYZ where Z is a zoom level ...

```{r, fig.align='center', fig.height = 6, echo = FALSE}
knitr::include_graphics('images/15-pyramid.jpg')
```

## Our Data for today ...

#### Southern Counties

```{r}
south_counties = aoi_get(state = "south", county = "all") |> 
  st_transform(st_crs(cities))
```

<br>

#### Unioned to States using `dplyr`

```{r}
south_states = south_counties |> 
  group_by(state_name) |> 
  summarise()
```

<br>

#### South County Centroids

```{r}
south_cent = st_centroid(south_counties)
```

```{r, echo = FALSE}
ggplot() + 
  geom_sf(data = south_counties, lty = 2) + 
  geom_sf(data = south_states, fill = NA, lwd = .75) + 
  geom_sf(data = south_cent, col = 'darkred', size = .2) +
  theme_void()
```

## Southern Coverage: County

```{r, fig.align='center', fig.width =10, echo = FALSE}
plot_tess(south_counties, "Counties")
```

## Regular Tiles

- One way to tile a surface is into regions of equal area

- Tiles can be either _square_ (rectilinear) or _hexagonal_

- `st_make_grid` generates a square or hexagonal grid covering the geometry of an `sf` or `sfc` object

- The return object of `st_make_grid` is a new `sfc` object 

- Grids can be specified by _cellsize_ or number of grid cells (*n*) in the X and Y direction

```{r}
# Create a grid over the south with 70 rows and 50 columns
sq_grid = st_make_grid(south_counties, n = c(70, 50)) |> 
  st_as_sf() |> 
  mutate(id = 1:n())
```

## Southern Coverage: Square

```{r, fig.align='center', fig.width=10, echo = FALSE}
plot_tess(sq_grid, "Square Coverage")
```

## Hexagonal Grid

- Hexagonal tessellations (honey combs) offer an alternative to square grids

- They are created in the same way but by setting `square = FALSE`

```{r}
hex_grid = st_make_grid(south_counties, n = c(70, 50), square = FALSE) |> 
  st_as_sf() |> 
  mutate(id = 1:n())
```

## Southern Coverage: Hexagon

```{r, fig.align='center', fig.width=10, echo = FALSE}
plot_tess(hex_grid, "Hexegonal Coverage")
```

## Advantages Square Grids

 - Simple definition and data storage
    - Only need the origin (lower left), cell size (XY) and grid dimensions
    
 - Easy to aggregate and dissaggregate (resample)
 
 - Analogous to raster data
 
 - Relationship between cells is given 
 
 - Combining layers is easy with traditional matrix algebra


## Advantages Square Grids 

 - Reduced Edge Effects
    - Lower perimeter to area ratio
    - minimizes the amount line length needed to create a lattice of cells with a given area
    
 - All neighbors are identical
    - No rook vs queen neighbors
    
 - Better fit to curve surfaces (e.g. the earth)

##

```{r, fig.align='center', fig.width = 18, echo = FALSE}
knitr::include_graphics('images/15-hex-vs-others.png')
```

## Triangulations

- An alternative to creating equal area tiles is to create triangulations from known **anchor points**

- Triangulation requires a set of input points and seeks to partition the interior into a partition of triangles.

- In GIS contexts you'll hear:
  - Thiessen Polygon 
  - Voronoi Regions
  - Delunay Triangulation
  - TIN (Triangular irregular networks)
  - etc,..

## Voronoi Polygons

- Voronoi/Thiessen polygon boundaries define the area closest to each anchor point relative to all others

- They are defined by the _perpendicular_ bisectors of the lines between all points.

```{r, fig.align='center', fig.height = 8, echo = FALSE}
knitr::include_graphics('images/15-voronoi-animation.gif')
```

## Voronoi Polygons

```{r, fig.align='center', fig.height = 8, echo = FALSE}
knitr::include_graphics('images/15-Voronoi_growth_euclidean.gif')
```

## Voronoi Polygons

- Usefull for tasks such as: 
  - nearest neighbor search, 
  - facility location (optimization), 
  - largest empty areas, 
  - path planning...

- Also useful for simple interpolation of values such as rain gauges,

::: columns
::: {.column width="50%"}
```{r, echo = FALSE, fig.width = 6}
knitr::include_graphics('images/15-gage-rainfall.png')
```
:::
::: {.column width="50%"}
```{r, echo = FALSE, fig.width = 6}
knitr::include_graphics('images/15-triangle-rainfall.png')
```
:::
:::

## Often used in numerical models and simulations

::: columns
::: {.column width="50%"}
```{r, echo = FALSE, fig.width = 6}
knitr::include_graphics('images/15-ocean-eddy.png')
```
:::
::: {.column width="50%"}
```{r, echo = FALSE, fig.width = 6}
knitr::include_graphics('images/15-jetstream.png')
```
:::
:::

## `st_voronoi`

- st_voronoi creates voronoi tesselation in `sf`

- It works over a `MULTIPOINT` collection

- Should always be simplified after creation (st_cast())

- If to be treated as an object for analysis, should be id'd

```{r}
south_cent_u = st_union(south_cent)

v_grid = st_voronoi(south_cent_u) |> 
  st_cast() |> 
  st_as_sf() |> 
  mutate(id = 1:n())
```

## Southern Coverage: Voronoi

```{r, fig.align='center', fig.width=10, echo = FALSE}
plot_tess(v_grid, "Voronoi Coverage")
```

## Southern Coverage: Voronoi

```{r, fig.align='center', fig.width=10, echo = FALSE}
v_grid = st_intersection(v_grid, st_union(south_states))
```

```{r, fig.align='center', fig.width=10, echo = FALSE}
plot_tess(v_grid, "Voroni Coverage") + 
  geom_sf(data = south_cent, col = "darkred", size = .2)
```

## Delaunay triangulation

- A Delaunay triangulation for a given set of points (P) in a plane, is a triangulation DT(P), where no point is inside the circumcircle of any triangle in DT(P). 

```{r, fig.align='center', fig.height = 8, echo = FALSE}
knitr::include_graphics('images/15-Delaunay_triangles.gif')
```

## Delaunay triangulation

- The Delaunay triangulation of a discrete POINT set corresponds to the dual graph of the Voronoi diagram. 

- The circumcenters (center of circles) of Delaunay triangles are the vertices of the Voronoi diagram. 

```{r,  fig.width = 10, fig.align='center', echo = FALSE}
knitr::include_graphics('images/15-vor-delun.png')
```

## Used in landscape evaluation and terrian modeling

::: columns
::: {.column width="50%"}

```{r,  fig.height = 6, echo = FALSE}
knitr::include_graphics('images/15-flood-plain-mapping.jpg')
```
::: 
::: {.column width="50%"}
```{r,echo = FALSE}
knitr::include_graphics('images/15-tin-terrain.jpg')
```
:::
:::

## `st_triangulate`

- `st_triangulate` creates Delaunay triangulation in `sf`

- It works over a `MULTIPOINT` collection

- Should always be simplified after creation (`st_cast()`)

- If to be treated as an object for analysis, should be id'd

```{r}
t_grid = st_triangulate(south_cent_u) |> 
  st_cast() |> 
  st_as_sf() |> 
  mutate(id = 1:n())
```

## Southern Coverage: Triangles

```{r, fig.align='center', fig.width=10, echo = FALSE}
plot_tess(t_grid, "Triangular Coverage")
```

## Southern Coverage: Triangles

```{r, fig.align='center', fig.width=10}
t_grid = st_intersection(t_grid, st_union(south_states))
```

```{r, fig.align='center', fig.width=10, echo = FALSE}
plot_tess(t_grid, "Voroni Coverage") + 
  geom_sf(data = south_cent, col = "darkred", size = .3)
```

## Difference in object coverages:

```{r, echo = FALSE}
sum_tess = function(data, type){
  areakm2 = drop_units(set_units(st_area(data), "km2"))
  data.frame(type = type, count = length(areakm2),  mean = mean(areakm2),  sd = sd(areakm2), tot = sum(areakm2))
}

bind_rows(
  sum_tess(t_grid,"triangulation"),
  sum_tess(v_grid, "voroni"),
  sum_tess(south_counties, "counties"),
  sum_tess(sq_grid, "grid"),
  sum_tess(hex_grid, "Hexagon")) |> 
knitr::kable(caption = "Tesselation Characteristics",
               col.names = c("Type", "Elements", "Mean Area (km2)", "Standard Deviation Area (km2)" ,"Coverage Area"),
               format.args = list(big.mark = ",", digits = 2)) |>
  kableExtra::kable_styling("striped", full_width = T, font_size = 48)
```

## Modifiable areal unit problem (MAUP)

- The modifiable areal unit problem (MAUP) is a source of statistical bias that can significantly impact the results of statistical hypothesis tests. 

- MAUP affects results when point-based measures are aggregated into districts. 

- The resulting summary values (e.g., totals or proportions) are influenced by both the shape and scale of the aggregation unit.

```{r, fig.align='center', fig.width = 2, echo = FALSE}
knitr::include_graphics('images/15-maup.png')
```

# Real World Example

- The power of GIS is the ability to integrate different layers and types of information

- The scale of information can impact the analysis as can the grouping and zoning schemes chosen

- The Modifiable Areal Unit Problem (MAUP) is an important issue for those who conduct spatial analysis using units of analysis at aggregations higher than incident level. 

- The MAUP occurs when the aggregate units of analysis are arbitrarily produced or not directly related to the underlying phenomena. A classic example of this problem is Gerrymandering.

- Gerrymandering involves shaping and re-shaping voting districts based on the political affiliations of the resident citizenry. 

# [Examples](https://thefulcrum.us/worst-gerrymandering-districts-example)

```{r, fig.align='center', out.width="90%", echo = FALSE}
knitr::include_graphics('images/15-gm-maup.png')
```

## Wrap up
 
Today we covered the following topics:
- Spatial predicates and binary predicates
- Spatial filtering and joining
- Spatial simplification
- Spatial tessellations / Coverages
- Modifiable areal unit problem (MAUP)

Combined with your understanding of

- Geometry and topology
- Coordinate Reference Systems
- Their integration with R

We are well suited to move on to raster data (gridded coverage model!) next week

Congrats!!
