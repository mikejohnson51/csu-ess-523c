{
  "hash": "b78d6cb94f835b33bfbe5e78d8c85813",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Week 3\"\nsubtitle: \"Predicates, Simplification & Tesselations\"\nformat:\n  revealjs: \n    smaller: false\n    incremental: false\n    logo: ../csu-rams-logo.png\n    slide-number: c/t\n    footer: \"[ESS 523c: Environmental Data Science Applications: Water Resources](https://github.com/mikejohnson51/csu-ess-523c/)\"\n    include-before-body: header.html\n    include-after-body: footer-annotations.html\n    theme: [default, csu-css.scss]\n    width: 1600\n    height: 1000\n    countIncrementalSlides: false\n    title-slide-attributes:\n      data-background-color: \"#1E4D2B\"\nknitr:\n  opts_chunk: \n    echo: true\n    message: true\n    collapse: true\n    comment: \"#>\"\n    out.width: \"100%\"\n---\n\n\n\n\n\n# Last week\n\nWe learned about the SRS (Spatial Reference Systems)\n\n\n\n- They can be **geographic** (3D, angular units)\n\n\n\n  - Ellipsoid (squished sphere model)\n\n\n\n  - geoid (mathematical model of gravitational field)\n  \n\n  \n  - datum marks the relationship between the ellipsoid and geoid\n\n\n    - can be local (NAD27)\n    \n\n\n    - can be global (WGS84, NAD83)\n    \n\n  \n- SRS can be projected (x-y axis, measurement units (m), false origin)\n\n\n\n  - All PCS are based on GCS\n      \n\n  \n  - Projections seek to place the 3D earth on 2D\n      \n\n  \n  - Does this by defining a plane that can be conic, cylindrical or planar\n      \n\n  \n  - \"unfolding to this plane\" creates distortion of **shape**, **area**, **distance**, or **direction**\n      \n\n  \n  - The distortion is greater from point/lines of tangency or secanacy \n\n\n\n# Measures (GEOS Measures)\n\n- Measures are the questions we ask about the dimension of a geometry\n    \n  - How long is a line or polygon perimeter (unit)\n  \n  - What is the area of a polygon (unit^2^)\n  \n  - How far are two object from one another (unit)\n      \n- Measures come from the GEOS library\n    \n- Measures are in the **units** of the base projection\n    \n- Measures can be Euclidean (PCS) or geodesic (GSC)\n\n  - geodesic (Great Circle) distances can be more accurate by eliminating distortion\n\n  - but are much slower to calculate\n\n## For example ...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusa <- st_cast(st_union(aoi_get(state = \"conus\")), \"MULTILINESTRING\")\n\nnrow(cities)\n#> [1] 31254\n```\n:::\n\n\n\n<br>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Great Circle Distance in GCS\nsystem.time({x <- st_distance(usa, cities)})\n# user      system elapsed \n# 103.560   1.390  117.128 \n\n# Euclidean Distance on PCS\nsystem.time({x <- st_distance(usa, cities, which = \"Euclidean\")})\n# user    system  elapsed \n# 2.422   0.019   2.494 \n```\n:::\n\n\n\n## Units\n\nWhen possible measure operations report results with a units appropriate for the CRS:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco <- st_read(\"data/co.shp\")\n#> Reading layer `co' from data source \n#>   `/Users/mikejohnson/github/csu-ess-523c/slides/data/co.shp' \n#>   using driver `ESRI Shapefile'\n#> Simple feature collection with 64 features and 4 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -109.0602 ymin: 36.99246 xmax: -102.0415 ymax: 41.00342\n#> Geodetic CRS:  WGS 84\na <- st_area(co[1,])\nattributes(a) |> unlist()\n#> units.numerator1 units.numerator2            class \n#>              \"m\"              \"m\"          \"units\"\n```\n:::\n\n\n\nThe **units** package can be used to convert between units:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunits::set_units(a, km^2) # result in square kilometers\n#> 3062.85 [km^2]\nunits::set_units(a, ha) # result in hectares\n#> 306285 [ha]\n```\n:::\n\n\n\nand the results can be stripped of their attributes for cases where numeric values are needed (e.g. math operators and ggplot):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(a)\n#> [1] 3062849758\n```\n:::\n\n\n\n## Topologic Diminsion\n\nA **POINT** is shape with a dimension of 0 that occupies a single location in coordinate space.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# POINT defined as numeric vector\n(st_dimension(st_point(c(0,1))))\n#> [1] 0\n```\n:::\n\n\n\n\nA **LINESTRING** is shape that has a dimension of 1 (length)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# LINESTRING defined by matrix\n(st_dimension(st_linestring(matrix(1:4, nrow = 2))))\n#> [1] 1\n```\n:::\n\n\n\nA **POLYGON** is surface stored as a list of its exterior and interior rings. It has a dimension of 2. (area)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# POLYGON defined by LIST (interior and exterior rings)\n(st_dimension(st_polygon(list(matrix(c(1:4, 1,2), nrow = 3, byrow = TRUE)))))\n#> [1] 2\n```\n:::\n\n\n\n# Predicates\n\n## Geometric Interiors, Boundaries and Exteriors\n\nAll geometries have interior, boundary and exterior regions.\n\nThe terms `interior` and `boundary` are used in the context of algebraic topology and manifold theory and **not** general topology\n\nThe OGC has define these states for the common geometry types in the simple features standard:\n\n| Dimension \t| Geometry Type \t| Interior (I) \t| Boundary (B) \t|\n|:-\t|:-\t|:-\t|:-\t|\n| Point, MultiPoint             | 0   \t| Point, Points                                              \t| Empty            |  \n| LineString, Line              | 1   \t| Points that are left when the boundary points are removed. \t| Two end points.  |   \t\n| Polygon                       | 2   \t| Points within the rings.                                   \t| Set of rings.    |   \t\n  \n## Interior, Boundary and Exterior: POINTS\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-10-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Interior, Boundary and Exterior: LINESTRING\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-11-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Interior, Boundary and Exterior: POLYGON\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-12-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Summary\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-13-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Predicates\n\nIn the following, we are interested in the resulting geometry that occurs when 2 geometries are overlaid...\n\n## Overlap is a POINT: 0D\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-14-1.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-15-1.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-16-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Overlap is a LINESTRING: 1D\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-17-1.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-18-1.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-19-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Overlap is a POLYGON: 2D\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-20-1.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-21-1.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-22-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## No Overlap = FALSE\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-23-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n## Dimensionally Extended 9-Intersection Model\n\n- The DE-9IM is a **topological** model and (standard) used to describe the spatial relations of two geometries \n\n- Used in geometry, point-set topology, geospatial topology\n\n- The **DE-9IM** _matrix_ provides a way to classify geometry relations using the set **{0,1,2,F}** or **{T,F}**\n\n- With a **{T,F}** matrix domain, there are 512 possible relations that can be grouped into binary classification schemes. \n\n- About 10 of these, have been given a common name such as _intersects_, _touches_, and _within_. \n\n- When testing two geometries against a scheme, the result is a spatial _predicate_ named by the scheme.\n\n- Provides the primary basis for queries and assertions in GIS and spatial databases (PostGIS).\n\n## The Matrix Model\n\nThe **DE-9IM** matrix is based on a 3x3 intersection matrix:\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/12-de-9Im-matrix.png){fig-align='center' width=50%}\n:::\n:::\n\n\n\nWhere: \n\n  - **dim** is the dimension of the intersection and\n  - I is the interior\n  - B is the boundary\n  - E is the exterior \n\n. . . \n\nEmpty sets are denoted as **F** \n\nnon-empty sets are denoted with the maximum dimension of the intersection *{0,1,2}*\n\n## \n\nA simpler (binary) version of this matrix can be created by mapping all non-empty intersections {0,1,2} to TRUE.\n\n![](images/12-de-9Im-matrix-simple.svg)\n\nWhere `II` would state: \"Does the Interior of \"a\" overlaps with the Interior of \"b\" in a way that produces a point (0), line (1), or polygon (2)\"\n\nWhere `IB` would state: \"Does the Interior of \"a\" overlap with the Boundary of \"b\" in a way that produces a point (0), line (1), or polygon (2)\"\n\nBoth matrix forms:\n  - dimensional {0,1,2,F}\n  - Boolean {T,F}\n  \n. . . \n\nCan be serialize as a \"DE-9IM string code\" representing the matrix in a single string element (standardized format for data interchange)\n\nThe OGC has standardized the typical spatial predicates (Contains, Crosses, Intersects, Touches, etc.) as *Boolean* functions, and the DE-9IM model as a function that returns the DE-9IM code, with domain of {0,1,2,F}\n\n## Illustration\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/12-de-91m-figure.png){fig-align='center' width=50%}\n:::\n:::\n\n\n\nReading from left-to-right and top-to-bottom, the DE-9IM(a,b) string code is '212101212'\n\n## Spatial Relations in R\n\n- Geometry X is a 3 feature polygon colored in red\n- Geometry Y is a 4 feature polygon colored in blue\n\n::: columns\n::: {.column-width = \"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-26-1.png){width=50%}\n:::\n:::\n\n\n::: {.column-width = \"50%\"}\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_relate(x,y)\n#>      [,1]        [,2]        [,3]        [,4]       \n#> [1,] \"212FF1FF2\" \"FF2FF1212\" \"212101212\" \"FF2FF1212\"\n#> [2,] \"FF2FF1212\" \"212101212\" \"212101212\" \"FF2FF1212\"\n#> [3,] \"FF2FF1212\" \"FF2FF1212\" \"212101212\" \"FF2FF1212\"\nst_relate(x,x)\n#>      [,1]        [,2]        [,3]       \n#> [1,] \"2FFF1FFF2\" \"FF2F01212\" \"FF2F11212\"\n#> [2,] \"FF2F01212\" \"2FFF1FFF2\" \"FF2FF1212\"\n#> [3,] \"FF2F11212\" \"FF2FF1212\" \"2FFF1FFF2\"\nst_relate(y,y)\n#>      [,1]        [,2]        [,3]        [,4]       \n#> [1,] \"2FFF1FFF2\" \"FF2FF1212\" \"212101212\" \"FF2FF1212\"\n#> [2,] \"FF2FF1212\" \"2FFF1FFF2\" \"212101212\" \"FF2FF1212\"\n#> [3,] \"212101212\" \"212101212\" \"2FFF1FFF2\" \"FF2FF1212\"\n#> [4,] \"FF2FF1212\" \"FF2FF1212\" \"FF2FF1212\" \"2FFF1FFF2\"\n```\n:::\n\n\n:::\n:::\n\n## Named Predicates {.smaller}\n\n- \"named spatial predicates\" have been defined for some common relations.\n\n- A few functions can be derived (expressed by masks) from DE-9IM include (* = wildcard):\n\n| Predicate \t| DE-9IM String Code \t| Description \t|\n|:-\t|:-\t|:-\t|\n| **Intersects** \t| `T*F**FFF*` \t| \"Two geometries intersect if they share any portion of space\" \t|\n| **Overlaps** \t| `T*F**FFF*` \t| \"Two geometries overlap if they share some but not all of the same space\" \t|\n| **Equals** \t| `T*F**FFF*` \t| \"Two geometries are topologically equal if their interiors intersect and no part of the interior or boundary of one geometry intersects the exterior of the other\" \t|\n| **Disjoint** \t| `FF*FF*****` \t| \"Two geometries are disjoint: they have no point in common. They form a set of disconnected geometries.\" \t|\n| **Touches** \t| `FT*******` | `F**T*****` | `F***T****` \t| \"Two geometries touch if they have at least one point in common, but their interiors do not intersect.\" \t|\n| **Contains** \t| `T*****FF**` \t| \"A contains B: geometry B lies in A, and the interiors intersect\" \t|\n| **Covers** \t| `T*****FF*` | `*T****FF*` | `***T**FF*` | `****T*FF*` \t| \"A covers B: geometry B lies in A.\" \t|\n| **Within** \t| `*T*****FF*` | `**T****FF*` | `***T**FF*` | `****T*FF*` \t| \"A within B: geometry A lies in B.\" \t|\n| **Covered by** \t| `*T*****FF*` | `**T****FF*` | `***T**FF*` | `****T*FF*` \t| \"A covered by B: geometry A lies in B.\" \t|\n\n## Binary Predicates\n\n- Collectively, predicates define the type of relationship each 2D object has with another.\n\n- Of the ~ 512 unique relationships offered by the DE-9IM models a selection of ~ 10 have been named.\n\n- These are include in PostGIS/GEOS and are made accessible via R sf\n\n\n\n::: {.cell layout-align=\"center\" fout.width='50%'}\n::: {.cell-output-display}\n![](images/13-sf-binary.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Named predicates in R \n\n- `sf` provides a set of functions that implement the DE-9IM model and named predicates. Each of these can return either a *sparse* or *dense* matrix.\n\n#### *sparse* matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_intersects(x,y)\n#> Sparse geometry binary predicate list of length 3, where the predicate\n#> was `intersects'\n#>  1: 1, 3\n#>  2: 2, 3\n#>  3: 3\n```\n:::\n\n\n\n#### *dense* matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_intersects(x, y, sparse = FALSE)\n#>       [,1]  [,2] [,3]  [,4]\n#> [1,]  TRUE FALSE TRUE FALSE\n#> [2,] FALSE  TRUE TRUE FALSE\n#> [3,] FALSE FALSE TRUE FALSE\n\nst_disjoint(x, y, sparse = FALSE)\n#>       [,1]  [,2]  [,3] [,4]\n#> [1,] FALSE  TRUE FALSE TRUE\n#> [2,]  TRUE FALSE FALSE TRUE\n#> [3,]  TRUE  TRUE FALSE TRUE\n\nst_touches(x, y, sparse = FALSE)\n#>       [,1]  [,2]  [,3]  [,4]\n#> [1,] FALSE FALSE FALSE FALSE\n#> [2,] FALSE FALSE FALSE FALSE\n#> [3,] FALSE FALSE FALSE FALSE\n\nst_within(x, y, sparse = FALSE)\n#>       [,1]  [,2]  [,3]  [,4]\n#> [1,] FALSE FALSE FALSE FALSE\n#> [2,] FALSE FALSE FALSE FALSE\n#> [3,] FALSE FALSE FALSE FALSE\n```\n:::\n\n\n\n## st_relates vs. predicate calls...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates = filter(aoi_get(state = \"all\"), state_abbr %in% c(\"WA\", \"OR\", \"MT\", \"ID\")) |>\n  select(name)\n\nwa = filter(states, name == \"Washington\")\n```\n:::\n\n\n\n::: columns\n::: {column.wdith = \"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(states$geometry)\n```\n\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-32-1.png){width=50%}\n:::\n:::\n\n\n:::\n::: {column.wdith = \"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(mutate(states, \n        deim9 = st_relate(states, wa),\n        touch = st_touches(states, wa, sparse = F)))\n#> Simple feature collection with 4 features and 3 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -124.8485 ymin: 41.98818 xmax: -104.0397 ymax: 49.00244\n#> Geodetic CRS:  WGS 84\n#>         name                       geometry     deim9 touch\n#> 1      Idaho MULTIPOLYGON (((-111.0455 4... FF2F11212  TRUE\n#> 2    Montana MULTIPOLYGON (((-109.7985 4... FF2FF1212 FALSE\n#> 3     Oregon MULTIPOLYGON (((-117.22 44.... FF2F11212  TRUE\n#> 4 Washington MULTIPOLYGON (((-121.5237 4... 2FFF1FFF2 FALSE\n```\n:::\n\n\n:::\n:::\n\n# So... \n\n- binary predicates return conditional _{T,F}_ relations based on predefined masks of the DE-9IM strings\n\n- Up to this point in class we have been using Boolean _{T,F}_ masks to filter data.frames by columns:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruits = c(\"apple\", \"orange\", \"lemon\", \"watermelon\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfruits == \"apple\"\n#> [1]  TRUE FALSE FALSE FALSE\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfruits %in% c(\"apple\", \"lemon\")\n#> [1]  TRUE FALSE  TRUE FALSE\n```\n:::\n\n\n\n## Filtering on data.frames\n\n- We have used `dplyr::filter` to  subset a data frame, retaining all rows that satisfy a `boolean` condition. \n\n::: columns\n::: {column.wdith = \"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(states, equalsWA = (name == \"Washington\")) |> \n  st_drop_geometry()\n#>         name equalsWA\n#> 1      Idaho    FALSE\n#> 2    Montana    FALSE\n#> 3     Oregon    FALSE\n#> 4 Washington     TRUE\n```\n:::\n\n\n:::\n::: {column.wdith = \"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(states, name == \"Washington\")\n#> Simple feature collection with 1 feature and 1 field\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -124.8485 ymin: 45.54364 xmax: -116.9161 ymax: 49.00244\n#> Geodetic CRS:  WGS 84\n#>         name                       geometry\n#> 1 Washington MULTIPOLYGON (((-121.5237 4...\n```\n:::\n\n\n:::\n:::\n\n## Spatial Filtering\n \n- We can filter spatially, use `st_filter` as the function call\n\n- Here the `boolean` condition is not passed (e.g. name == WA)\n\n- But instead, is defined by a spatial predicate\n\n- The default is `st_intersects` but can be changed with the `.predicate` argument:\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(states, \n       touch = st_touches(states, wa, sparse = FALSE)) \n#> Simple feature collection with 4 features and 2 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -124.8485 ymin: 41.98818 xmax: -104.0397 ymax: 49.00244\n#> Geodetic CRS:  WGS 84\n#>         name                       geometry touch\n#> 1      Idaho MULTIPOLYGON (((-111.0455 4...  TRUE\n#> 2    Montana MULTIPOLYGON (((-109.7985 4... FALSE\n#> 3     Oregon MULTIPOLYGON (((-117.22 44....  TRUE\n#> 4 Washington MULTIPOLYGON (((-121.5237 4... FALSE\n```\n:::\n\n\n:::\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_filter(states, wa, .predicate = st_touches) \n#> Simple feature collection with 2 features and 1 field\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -124.7035 ymin: 41.98818 xmax: -111.0435 ymax: 49.00085\n#> Geodetic CRS:  WGS 84\n#>     name                       geometry\n#> 1  Idaho MULTIPOLYGON (((-111.0455 4...\n#> 2 Oregon MULTIPOLYGON (((-117.22 44....\n```\n:::\n\n\n:::\n:::\n\n## Result \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(states) + \n  geom_sf() + \n  geom_sf(data = wa, fill = \"blue\", alpha = .3) +\n  geom_sf(data = st_filter(states, wa, .predicate = st_touches), fill = \"red\", alpha = .5) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-41-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Distance Example (additional parameter)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncities = read_csv(\"../labs/data/uscities.csv\") |> \n  st_as_sf(coords = c(\"lng\", \"lat\"), crs = 4326) |> \n  select(city, population, state_name) |> \n  st_transform(5070)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_filter(cities, \n          filter(cities, city == \"Fort Collins\"), \n          .predicate = st_is_within_distance, 10000) \n#> Simple feature collection with 2 features and 3 fields\n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: -760147.5 ymin: 1982249 xmax: -751658.3 ymax: 1984621\n#> Projected CRS: NAD83 / Conus Albers\n#> # A tibble: 2 × 4\n#>   city         population state_name            geometry\n#> * <chr>             <dbl> <chr>              <POINT [m]>\n#> 1 Fort Collins     339256 Colorado   (-760147.5 1984621)\n#> 2 Timnath            8007 Colorado   (-751658.3 1982249)\n```\n:::\n\n\n\n# Spatial Data Science\n\n- Filtering is a nice way to reduce the dimensions of a **single** dataset\n\n- Often \"*... one table is not enough... *\"\n\n- In these cases we want to combine - or **join** -  data \n \n\n# Spatial Joining\n\n- Joining two non-spatial datasets relies on a shared _key_  that uniquely identifies each record in a table\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/07-joins.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n- Spatially joining data relies on shared _geographic relations_ rather then a shared _key_\n\n- Like filter, these relations can be defined by a **predicate**\n\n- As with tabular data, mutating joins *add* data to the target object (x) from a source object (y).\n\n## st_join\n\n- In `sf` `st_join` provides this joining capacity\n\n- By default, `st_join` performs a _left_ join (Returns all records from x, and the matched records from y)\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-left-join.png){fig-align='center' width=25%}\n:::\n:::\n\n\n\n- It can also do inner joins by setting `left = FALSE`. \n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-inner-join.png){fig-align='center' width=25%}\n:::\n:::\n\n\n\n- The default predicate for `st_join` (and `st_filter`) is `st_intersects`\n\n- This can be changed with the join argument (see `?st_join` for details).\n\n# Every Starbucks in the World\n\nWhat county has the most Starbucks in each state?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(starbucks = readr::read_csv('../labs/data/directory.csv') |> \n  filter(!is.na(Latitude), Country == \"US\") |> \n  st_as_sf(coords = c(\"Longitude\", \"Latitude\"), crs = 4326) |> \n  st_transform(5070))\n#> Simple feature collection with 13608 features and 11 fields\n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: -6223543 ymin: 278590.9 xmax: 2122577 ymax: 5307178\n#> Projected CRS: NAD83 / Conus Albers\n#> # A tibble: 13,608 × 12\n#>    Brand     `Store Number` `Store Name` `Ownership Type` `Street Address` City \n#>  * <chr>     <chr>          <chr>        <chr>            <chr>            <chr>\n#>  1 Starbucks 3513-125945    Safeway-Anc… Licensed         5600 Debarr Rd … Anch…\n#>  2 Starbucks 74352-84449    Safeway-Anc… Licensed         1725 Abbott Rd   Anch…\n#>  3 Starbucks 12449-152385   Safeway - A… Licensed         1501 Huffman Rd  Anch…\n#>  4 Starbucks 24936-233524   100th & C S… Company Owned    320 W. 100th Av… Anch…\n#>  5 Starbucks 8973-85630     Old Seward … Company Owned    1005 E Dimond B… Anch…\n#>  6 Starbucks 72788-84447    Fred Meyer … Licensed         1000 E Northern… Anch…\n#>  7 Starbucks 79549-106150   Safeway - A… Licensed         3101 PENLAND PK… Anch…\n#>  8 Starbucks 75988-107245   ANC Main Te… Licensed         HMSHost, 500 We… Anch…\n#>  9 Starbucks 11426-99254    Tudor Rd an… Company Owned    110 W. Tudor Rd… Anch…\n#> 10 Starbucks 20349-108249   Fred Meyer-… Licensed         7701 Debarr Road Anch…\n#> # ℹ 13,598 more rows\n#> # ℹ 6 more variables: `State/Province` <chr>, Country <chr>, Postcode <chr>,\n#> #   `Phone Number` <chr>, Timezone <chr>, geometry <POINT [m]>\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties = aoi_get(state = \"conus\", county = \"all\") |> \n  st_transform(5070) |> \n  select(name, state_name)\n```\n:::\n\n\n\n## \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntopSB <- st_join(counties, starbucks) |> \n  group_by(name, state_name) |> \n  summarise(n = n()) |> \n  group_by(state_name) |> \n  slice_max(n, n = 1) |> \n  ungroup()\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-50-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## \n\n- Neither _joining_ nor _filtering_ spatially alter the underlying geometry of the features\n- In cases where we seek to alter a geometry based on another, we need clipping methods\n\n## Clipping \n\n- Clipping is a form of subsetting that involves changing the geometry of at least some features.\n\n- Clipping can only apply to features more complex than points: (lines, polygons and their ‘multi’ equivalents). \n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-clipping.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Spatial Subsetting\n\n- By default the data.frame subsetting methods we've seen (e.g `[,]`) implements `st_intersection`\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwa = st_transform(wa, 5070)\nwa_starbucks = starbucks[wa,] #<<\n\nggplot() + geom_sf(data = wa) + geom_sf(data = wa_starbucks) + theme_void()\n```\n\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-52-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n# Simplification\n\n# Computational Complexity\n\n- In all the cases we have looked at, the number of `POINT` (e.g geometries, nodes, or vertices) define the complexity of the predicate or the clip\n\n- Computational needs increase with the number of POINTS / NODES / VERTICES\n\n- **Simplification** is a process for generalization  vector objects (lines and polygons) \n\n- Another reason for simplifying objects is to reduce the amount of memory, disk space and network bandwidth they consume\n\n- Other times the level of detail captured in a geometry is either not needed, or, even counter productive the the scale/purpose of an analysis\n\n- If you are cropping features to a national border, how much detail do you need? The more points in your border, the long the clip operation will take....\n\n##\n\nIn cases where we want to reduce the complexity in a geometry we can use simplification algorithms\n\nThe most common algorithms are Ramer–Douglas–Peucker and Visvalingam-Whyatt.\n\n## Ramer–Douglas–Peucker\n\n- Mark the `first` and `last` points as kept\n\n- Find the point, `p` that is the farthest from the first-last line segment. If there are no points between first and last we are done (the base case)\n\n- If `p` is closer than `tolerance` units to the line segment then everything between first and last can be discarded\n\n- Otherwise, mark p as kept and repeat steps 1-4 using the points between first and p and between p and last (the call to recursion)\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-douglas-peucker-animated.gif){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## st_simplify\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-postgis-st-simplify.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n## st_simplify\n\n-  `sf` provides `st_simplify`, which uses the GEOS implementation of the Douglas-Peucker algorithm to reduce the vertex count. \n\n- `st_simplify` uses the `dTolerance` to control the level of generalization in map units (see Douglas and Peucker 1973 for details). \n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-r-st-simplify.png){fig-align='center' width=50%}\n:::\n:::\n\n\n\n##\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusa = aoi_get(state = \"conus\") |> \n  st_union() |> \n  st_transform(5070)\n\nusa1000   = st_simplify(usa, dTolerance = 10000)\nusa10000  = st_simplify(usa, dTolerance = 100000)\nusa100000 = st_simplify(usa, dTolerance = 1000000)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-57-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## \n\n- A limitation with Douglas-Peucker (therefore st_simplify) is that it simplifies objects on a per-geometry basis. \n\n- This means the ‘topology’ is lost, resulting in overlapping and disconnected geometries. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates = st_transform(states, 5070)\nsimp_states   = st_simplify(states, dTolerance = 20000)\nplot(simp_states$geometry)\n```\n\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-58-1.png){width=100%}\n:::\n:::\n\n\n\n## Visvalingam\n\n- The Visvalingam algorithm overcomes some limitations of the Douglas-Peucker algorithm (Visvalingam and Whyatt 1993).\n- it progressively removes points with the least-perceptible change. \n- Simplification often allows the elimination of 95% or more points while retaining sufficient detail for visualization and often analysis\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-ms-simplify.png){fig-align='center' width=50%}\n:::\n:::\n\n\n\n## rmapshaper\n\nIn R, the `rmapshaper` package implements the Visvalingam algorithm in the `ms_simplify` function. \n\n- The `ms_simplify` function is a wrapper around the `mapshaper` JavaScript library (created by lead viz experts at the NYT)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rmapshaper)\n\nusa10 = ms_simplify(usa, keep = .1)\nusa5  = ms_simplify(usa, keep = .05)\nusa1  = ms_simplify(usa, keep = .01)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-61-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n##\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates = st_transform(states, 5070)\nsimp_states   = ms_simplify(states, keep = .05)\nplot(simp_states$geometry)\n```\n\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-62-1.png){width=100%}\n:::\n:::\n\n\n\n##\n\nIn all cases, the number of points in a geometry can be calculated with `mapview::npts()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates = st_transform(states, 5070)\nsimp_states_st   = st_simplify(states, dTolerance = 20000)\nsimp_states_ms   = ms_simplify(states, keep = .05)\n\nmapview::npts(states)\n#> [1] 5930\nmapview::npts(simp_states_st)\n#> [1] 53\nmapview::npts(simp_states_ms)\n#> [1] 292\n```\n:::\n\n\n\n# Tesselation\n\n- So far we have spent the last few days looking at simple feature objects\n\n- Where a feature as a geometry define by a set of structured POINT(s) \n\n- These points have precision and define location ({X Y CRS})\n\n- The geometry defines a bounds: either 0D, 1D or 2D \n\n- Each object is therefore bounded to those geometries implying a level of exactness.\n\n## Core Concepts of Spatial Data: ([Kuhn 2012](https://www.tandfonline.com/doi/full/10.1080/13658816.2012.722637))\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/15-cc.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Core Concepts of Spatial Data: ([Kuhn 2012](https://www.tandfonline.com/doi/full/10.1080/13658816.2012.722637))\n\n- **One Base Concept**: Location\n\n- **Four Content Concepts**: Field, Object, Network, Event\n\n- **Two Quality Concepts**: Granularity, Accuracy\n\n## Core Concepts of Spatial Data: ([Kuhn 2012](https://www.tandfonline.com/doi/full/10.1080/13658816.2012.722637))\n\n- **One Base Concept**: Location (*coordinates*)\n\n- **Four Content Concepts**: Field (*raster*), Object (*simple feature*), <del>Network</del>, <del>Event</del>\n\n- **Two Quality Concepts**: Granularity (*simplification*), Accuracy (*taken for granted*)\n\n\n## Object View\n\n- Objects describe *individuals* that have an identity (id) as well as spatial, temporal, and thematic properties. \n\n- Answers questions about _properties_ and _relations_ of objects. \n\n- Results from fixing theme, controlling time, and measuring space. \n\n- Features, such as surfaces, depend on objects (but are also objects)\n\n## Object View\n\n- Object implies boundedness\n\n    - boundaries may not be known or even knowable, but have limits. \n\n- Crude examples of such limits are the minimal bounding boxes used for indexing and querying objects in databases. \n\n- Many objects (particularly natural ones) do not have crisp boundaries (watersheds) \n\n- Differences between spatial information from multiple sources are often caused by more or less arbitrary delineations through context-dependent boundaries. \n\n- Many questions about objects and features can be answered without boundaries, using simple point representations (centroids) with thematic _attributes_.\n\n\n## Field View\n\n- Fields describe phenomena that have a scalar or vector attribute everywhere in a space of interest \n\n  - for example, air temperatures, rainfall, elevation, land cover \n  \n- Field information answers the question **what is here?**, where here can be anywhere in the space considered. \n\n- Field-based spatial information can also represent attributes that are computed rather than measured, such as probabilities or densities.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/15-prob-snow-christmas.jpg){fig-align='center' width=100%}\n:::\n:::\n\n\n\nTogether, fields and objects are  the two fundamental ways of structuring spatial information. \n\n## Objects can provide coverage:\n\n- Both objects and fields can cover space continuously - the primary difference is that objects prescribe bounds.\n\n  - Counties are one form of object that covers the USA seamlessly\n\n  - State objects are another ...\n\n# Object Coverages\n\n## LANDSAT Path Row\n\n- Serves tiles based on a path/row index\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-66-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n## MODIS Sinisoial Grid\n\n- Serves tiles based on a path/row index\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-67-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## [Uber Hex Addressing](https://eng.uber.com/h3/)\n\n- Breaks the world into Hexagons...\\\n\n<br>\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/15-uber-h3.jpeg){width=100%}\n:::\n:::\n\n\n\n:::\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/15-uber-h3-zoom.jpeg){width=100%}\n:::\n:::\n\n\n\n:::\n:::\n\n## [what3word](https://what3words.com/switched.mandates.apple)\n\n- Breaks the world into 3m grids encoded with unique 3 word strings\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/15-what3words.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## [Map Tiles / slippy maps / Pyramids](https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames)\n\n- Use XYZ where Z is a zoom level ...\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/15-pyramid.jpg){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Our Data for today ...\n\n#### Southern Counties\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsouth_counties = aoi_get(state = \"south\", county = \"all\") |> \n  st_transform(st_crs(cities))\n```\n:::\n\n\n\n<br>\n\n#### Unioned to States using `dplyr`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsouth_states = south_counties |> \n  group_by(state_name) |> \n  summarise()\n```\n:::\n\n\n\n<br>\n\n#### South County Centroids\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsouth_cent = st_centroid(south_counties)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-75-1.png){width=100%}\n:::\n:::\n\n\n\n## Southern Coverage: County\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-76-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Regular Tiles\n\n- One way to tile a surface is into regions of equal area\n\n- Tiles can be either _square_ (rectilinear) or _hexagonal_\n\n- `st_make_grid` generates a square or hexagonal grid covering the geometry of an `sf` or `sfc` object\n\n- The return object of `st_make_grid` is a new `sfc` object \n\n- Grids can be specified by _cellsize_ or number of grid cells (*n*) in the X and Y direction\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a grid over the south with 70 rows and 50 columns\nsq_grid = st_make_grid(south_counties, n = c(70, 50)) |> \n  st_as_sf() |> \n  mutate(id = 1:n())\n```\n:::\n\n\n\n## Southern Coverage: Square\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-78-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Hexagonal Grid\n\n- Hexagonal tessellations (honey combs) offer an alternative to square grids\n\n- They are created in the same way but by setting `square = FALSE`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhex_grid = st_make_grid(south_counties, n = c(70, 50), square = FALSE) |> \n  st_as_sf() |> \n  mutate(id = 1:n())\n```\n:::\n\n\n\n## Southern Coverage: Hexagon\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-80-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Advantages Square Grids\n\n - Simple definition and data storage\n    - Only need the origin (lower left), cell size (XY) and grid dimensions\n    \n - Easy to aggregate and dissaggregate (resample)\n \n - Analogous to raster data\n \n - Relationship between cells is given \n \n - Combining layers is easy with traditional matrix algebra\n\n\n## Advantages Square Grids \n\n - Reduced Edge Effects\n    - Lower perimeter to area ratio\n    - minimizes the amount line length needed to create a lattice of cells with a given area\n    \n - All neighbors are identical\n    - No rook vs queen neighbors\n    \n - Better fit to curve surfaces (e.g. the earth)\n\n##\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/15-hex-vs-others.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Triangulations\n\n- An alternative to creating equal area tiles is to create triangulations from known **anchor points**\n\n- Triangulation requires a set of input points and seeks to partition the interior into a partition of triangles.\n\n- In GIS contexts you'll hear:\n  - Thiessen Polygon \n  - Voronoi Regions\n  - Delunay Triangulation\n  - TIN (Triangular irregular networks)\n  - etc,..\n\n## Voronoi Polygons\n\n- Voronoi/Thiessen polygon boundaries define the area closest to each anchor point relative to all others\n\n- They are defined by the _perpendicular_ bisectors of the lines between all points.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/15-voronoi-animation.gif){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Voronoi Polygons\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/15-Voronoi_growth_euclidean.gif){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Voronoi Polygons\n\n- Usefull for tasks such as: \n  - nearest neighbor search, \n  - facility location (optimization), \n  - largest empty areas, \n  - path planning...\n\n- Also useful for simple interpolation of values such as rain gauges,\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/15-gage-rainfall.png){width=100%}\n:::\n:::\n\n\n:::\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/15-triangle-rainfall.png){width=100%}\n:::\n:::\n\n\n:::\n:::\n\n## Often used in numerical models and simulations\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/15-ocean-eddy.png){width=100%}\n:::\n:::\n\n\n:::\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/15-jetstream.png){width=100%}\n:::\n:::\n\n\n:::\n:::\n\n## `st_voronoi`\n\n- st_voronoi creates voronoi tesselation in `sf`\n\n- It works over a `MULTIPOINT` collection\n\n- Should always be simplified after creation (st_cast())\n\n- If to be treated as an object for analysis, should be id'd\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsouth_cent_u = st_union(south_cent)\n\nv_grid = st_voronoi(south_cent_u) |> \n  st_cast() |> \n  st_as_sf() |> \n  mutate(id = 1:n())\n```\n:::\n\n\n\n## Southern Coverage: Voronoi\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-89-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Southern Coverage: Voronoi\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-91-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Delaunay triangulation\n\n- A Delaunay triangulation for a given set of points (P) in a plane, is a triangulation DT(P), where no point is inside the circumcircle of any triangle in DT(P). \n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/15-Delaunay_triangles.gif){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Delaunay triangulation\n\n- The Delaunay triangulation of a discrete POINT set corresponds to the dual graph of the Voronoi diagram. \n\n- The circumcenters (center of circles) of Delaunay triangles are the vertices of the Voronoi diagram. \n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/15-vor-delun.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Used in landscape evaluation and terrian modeling\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/15-flood-plain-mapping.jpg){width=100%}\n:::\n:::\n\n\n::: \n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/15-tin-terrain.jpg){width=100%}\n:::\n:::\n\n\n:::\n:::\n\n## `st_triangulate`\n\n- `st_triangulate` creates Delaunay triangulation in `sf`\n\n- It works over a `MULTIPOINT` collection\n\n- Should always be simplified after creation (`st_cast()`)\n\n- If to be treated as an object for analysis, should be id'd\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt_grid = st_triangulate(south_cent_u) |> \n  st_cast() |> \n  st_as_sf() |> \n  mutate(id = 1:n())\n```\n:::\n\n\n\n## Southern Coverage: Triangles\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-97-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Southern Coverage: Triangles\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nt_grid = st_intersection(t_grid, st_union(south_states))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](week-3_files/figure-revealjs/unnamed-chunk-99-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Difference in object coverages:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"font-size: 48px; margin-left: auto; margin-right: auto;\">\n<caption style=\"font-size: initial !important;\">Tesselation Characteristics</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Type </th>\n   <th style=\"text-align:right;\"> Elements </th>\n   <th style=\"text-align:right;\"> Mean Area (km2) </th>\n   <th style=\"text-align:right;\"> Standard Deviation Area (km2) </th>\n   <th style=\"text-align:right;\"> Coverage Area </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> triangulation </td>\n   <td style=\"text-align:right;\"> 2,828 </td>\n   <td style=\"text-align:right;\"> 832 </td>\n   <td style=\"text-align:right;\"> 557 </td>\n   <td style=\"text-align:right;\"> 2,352,288 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> voroni </td>\n   <td style=\"text-align:right;\"> 1,421 </td>\n   <td style=\"text-align:right;\"> 1,688 </td>\n   <td style=\"text-align:right;\"> 1,046 </td>\n   <td style=\"text-align:right;\"> 2,398,383 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> counties </td>\n   <td style=\"text-align:right;\"> 1,421 </td>\n   <td style=\"text-align:right;\"> 1,688 </td>\n   <td style=\"text-align:right;\"> 1,216 </td>\n   <td style=\"text-align:right;\"> 2,398,383 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> grid </td>\n   <td style=\"text-align:right;\"> 3,500 </td>\n   <td style=\"text-align:right;\"> 1,470 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 5,144,369 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Hexagon </td>\n   <td style=\"text-align:right;\"> 3,789 </td>\n   <td style=\"text-align:right;\"> 1,425 </td>\n   <td style=\"text-align:right;\"> 0 </td>\n   <td style=\"text-align:right;\"> 5,398,416 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n## Modifiable areal unit problem (MAUP)\n\n- The modifiable areal unit problem (MAUP) is a source of statistical bias that can significantly impact the results of statistical hypothesis tests. \n\n- MAUP affects results when point-based measures are aggregated into districts. \n\n- The resulting summary values (e.g., totals or proportions) are influenced by both the shape and scale of the aggregation unit.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/15-maup.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n# Real World Example\n\n- The power of GIS is the ability to integrate different layers and types of information\n\n- The scale of information can impact the analysis as can the grouping and zoning schemes chosen\n\n- The Modifiable Areal Unit Problem (MAUP) is an important issue for those who conduct spatial analysis using units of analysis at aggregations higher than incident level. \n\n- The MAUP occurs when the aggregate units of analysis are arbitrarily produced or not directly related to the underlying phenomena. A classic example of this problem is Gerrymandering.\n\n- Gerrymandering involves shaping and re-shaping voting districts based on the political affiliations of the resident citizenry. \n\n# [Examples](https://thefulcrum.us/worst-gerrymandering-districts-example)\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/15-gm-maup.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n## Wrap up\n \nToday we covered the following topics:\n- Spatial predicates and binary predicates\n- Spatial filtering and joining\n- Spatial simplification\n- Spatial tessellations / Coverages\n- Modifiable areal unit problem (MAUP)\n\nCombined with your understanding of\n\n- Geometry and topology\n- Coordinate Reference Systems\n- Their integration with R\n\nWe are well suited to move on to raster data (gridded coverage model!) next week\n\nCongrats!!\n",
    "supporting": [
      "week-3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}