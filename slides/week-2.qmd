---
title: "Week 2"
subtitle: "Features, Projections & Measures"
format:
  revealjs: 
    smaller: true 
    logo: ../csu-rams-logo.png
    slide-number: c/t
    footer: "[ESS 523c: Environmental Data Science Applications: Water Resources](https://github.com/mikejohnson51/csu-ess-523c/)"
    include-before-body: header.html
    include-after-body: footer-annotations.html
    theme: [default, csu-css.scss]
    highlightStyle: github
    highlightLines: true
    width: 1600
    height: 720
    countIncrementalSlides: false
    incremental: false
    title-slide-attributes:
      data-background-color: "#1E4D2B"
knitr:
  opts_chunk: 
    echo: true
    collapse: true
    comment: "#>"
---

```{r, include = F}
knitr::opts_chunk$set(fig.width = 6, message = TRUE, warning = FALSE, comment = "", cache = FALSE, fig.retina = 3)

library(tidyverse)
library(sf)
library(flipbookr)

co <- AOI::aoi_get(state = "CO", county = "all") |> 
  select(geoid = fip_code, name, aland = land_area, state_nm = state_name)
```

## Simple Features

```{r, echo = FALSE, fig.align="center", out.width="75%"}
knitr::include_graphics("images/09-sf-model.png")
```

## Todays Data:

```{r, echo = FALSE}
co
```


## Simple Features 

- Simple feature geometries describe the geometries of `features.` 

- The main application of simple feature geometries is to describe 2D geometries as `points`, `lines`, or `polygons`.

- “simple” refers to the fact that line or polygon geometries are represented by set of points connected with straight lines.

- Simple features access is a standard (Herring 2011, Herring (2010), ISO (2004)) for describing simple feature geometries via:

  1. a class hierarchy
  
  2. a set of operations
  
  3. binary and text encodings


## Simple Features Access

- [Simple features](https://en.wikipedia.org/wiki/Simple_Features) or [_simple feature access_](http://www.opengeospatial.org/standards/sfa) refers to the formal standard (ISO 19125-1:2004) describing how objects in the real world can be represented in computers, with emphasis on the _spatial_ geometry of these objects. 

- It also describes how objects can be stored in and retrieved from databases, and which geometrical operations should/can be defined for them.

- The standard is widely implemented in spatial databases (such as PostGIS), commercial GIS (e.g., [ESRI ArcGIS](http://www.esri.com/)) and forms the vector data basis for libraries such as [GDAL](http://www.gdal.org/). 

- A subset of simple features (e.g. the **big 7**) forms the [GeoJSON](http://geojson.org/) specification.

-  R has well-supported classes for storing spatial data ([sp](https://CRAN.R-project.org/package=sp)) and interfacing to the above mentioned environments ([rgdal](https://CRAN.R-project.org/package=rgdal), [rgeos](https://CRAN.R-project.org/package=rgeos)), but has so far lacked a complete implementation of simple features, making conversions at times convoluted, inefficient or incomplete. 

- [sf](http://github.com/r-spatial/sf) is seeking to fill this gap and has/will succeed [sp](https://CRAN.R-project.org/package=sp)

## So what is a feature?

- A feature is a thing (object) in the real world, such as a building or a river 

- They often consist of other objects. 

  - A river system can be a feature, a river can be a feature, a river outlet can be a feature.

  - A image pixel can be a feature, and the image can be a feature...

## Spatial Features

- The standard says: "_A simple feature is defined by the OpenGIS Abstract specification to have both **spatial** and **non-spatial** attributes. Spatial attributes are geometry valued, and simple features are based on 2D geometry with linear interpolation between vertices._"  - [standard](http://www.opengeospatial.org/standards/sfa).

- Spatial Features have a _geometry_ describing _where_  the feature is located and _how_ it is represented.

```{r}
str(co$geometry)
```

- The geometry of a river can be its watershed, of its mainstem, or the point it drains to (see the OGC [HY_Feature](https://docs.opengeospatial.org/is/14-111r6/14-111r6.html) standard) 
- Features can have attributes describing other properties of the feature 

- Other properties may include its length, slope, stream order or average flowrate

## Geometry types

The following 7 simple feature types are the most common, and are the only ones used for [GeoJSON](https://tools.ietf.org/html/rfc7946):

| SINGLE | Description                                        |
| ---- | -------------------------------------------------- |
| `POINT` | zero-dimensional geometry containing a single point |
| `LINESTRING` | sequence of points connected by straight, non-self intersecting line pieces; one-dimensional geometry |
| `POLYGON` | geometry with a positive area (two-dimensional); sequence of points form a closed, non-self intersecting ring; the first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring |

| MULTI (same typed) | Description                                        |
| ---- | -------------------------------------------------- |
| `MULTIPOINT` | set of points; a MULTIPOINT is simple if no two Points in the MULTIPOINT are equal |
| `MULTILINESTRING` | set of linestrings |
| `MULTIPOLYGON` | set of polygons |

| Multi-Typed | Description                                        |
| ---- | -------------------------------------------------- |
| `GEOMETRYCOLLECTION` | set of geometries of any type except GEOMETRYCOLLECTION |


- The descriptions above were copied from the [PostGIS manual](http://postgis.net/docs/using_postgis_dbmanagement.html).

## 

The remaining geometries 10 are rarer, but increasingly find implementations:

| type | description                                        |
| ---- | -------------------------------------------------- |
| `CIRCULARSTRING` | The CIRCULARSTRING is the basic curve type, similar to a LINESTRING in the linear world. A single segment requires three points, the start and end points (first and third) and any other point on the arc. The exception to this is for a closed circle, where the start and end points are the same. In this case the second point MUST be the center of the arc, i.e., the opposite side of the circle. To chain arcs together, the last point of the previous arc becomes the first point of the next arc, just like in LINESTRING. This means that a valid circular string must have an odd number of points greater than 1. |
| `COMPOUNDCURVE` | A compound curve is a single, continuous curve that has both curved (circular) segments and linear segments. That means that in addition to having well-formed components, the end point of every component (except the last) must be coincident with the start point of the following component. |
| `CURVEPOLYGON` | Example compound curve in a curve polygon: CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, 1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) ) |
| `MULTICURVE` |  A MultiCurve is a 1-dimensional GeometryCollection whose elements are Curves, it can include linear strings, circular strings or compound strings.  |
| `MULTISURFACE` | A MultiSurface is a 2-dimensional GeometryCollection whose elements are Surfaces, all using coordinates from the same coordinate reference system. |
| `CURVE` | A Curve is a 1-dimensional geometric object usually stored as a sequence of Points, with the subtype of Curve specifying the form of the interpolation between Points |
| `SURFACE` | A Surface is a 2-dimensional geometric object |
| `POLYHEDRALSURFACE` | A PolyhedralSurface is a contiguous collection of polygons, which share common boundary segments  |
| `TIN` | A TIN (triangulated irregular network) is a PolyhedralSurface consisting only of Triangle patches.|
| `TRIANGLE` | A Triangle is a polygon with 3 distinct, non-collinear vertices and no interior boundary |


## Dimensions

**All** geometries are composed of `points` 

  - Points are defined by coordinates in a 2-, 3- or 4-D space.  

  - In addition to XY coordinates, there are two optional dimensions:

  * a Z coordinate, denoting altitude
  * an M coordinate (rarely used), denoting some _measure_ 

  - The `M` describes  a property of the vertex that is *independent* of the feature. 

  - It sounds attractive to encode a time as M, however these quickly become invalid once the path self-intersects.

  - Both Z and M are found relatively **rarely**, and software support to do something useful with them is rarer still.

## Valid geometries

Valid geometries obey the following properties:

  - `LINESTRINGS` shall not self-intersect
  
  - `POLYGON` rings shall be closed (last point = first point)
  
  - `POLYGON` holes (inner rings) shall be inside their exterior ring
  
  - `POLYGON` inner rings shall maximally touch the exterior ring in single points, not over a line
  
  - `POLYGON` rings shall not repeat their own path
  
If any of the above is **not** the case, the geometry is not valid.

## Non-simple and non-valid geometries

`st_is_simple` and `st_is_valid` provide methods to help detect non-simple and non-valid geometries:

- An example of a non-simple geometries is a self-intersecting lines;

```{r}
(x1 <- st_linestring(cbind(c(0,1,0,1),c(0,1,1,0))))
st_is_simple(x1)
```

```{r echo=FALSE,fig=TRUE,out.width="20%", fig.align="center"}
opar <- par(mfrow = c(1,1))
par(mar=c(1,1,4,1))
plot(st_sfc(x1), type = 'b', axes = FALSE, xlab = NULL, ylab = NULL)
title(st_as_text(x1))
par(opar)
```

- An example of a non-valid geometry are would be a polygon with slivers or self-intersections.

```{r}
(x2 <- st_polygon(list(cbind(c(0,1,1,1,0,0),c(0,0,1,0.6,1,0)))))
(x3 <- st_polygon(list(cbind(c(0,1,0,1,0),c(0,1,1,0,0)))))

st_is_valid(c(x2,x3))
```

```{r echo=FALSE,fig=TRUE,out.width="20%", fig.align="center"}
opar <- par(mfrow = c(2,1))
par(mar=c(1,1,4,1))
plot(st_sfc(st_linestring((cbind(c(0,1,1,1,0,0),c(0,0,1,0.6,1,0))))), type='b', axes = FALSE)
title(st_as_text(x2))
plot(st_sfc(st_linestring(cbind(c(0,1,0,1,0),c(0,1,1,0,0)))), type = 'b', axes=F, xlab=NULL,ylab=NULL)
title(st_as_text(x3))
par(opar)
```


## Empty Geometries

- An important concept in the feature geometry framework is the `empty` geometry.

- `empty` geometries serve similar purposes as NA values in vectors (placeholder)

- Empty geometries arise naturally from geometrical operations, for instance:

```{r, message=TRUE}
(e = st_intersection(st_point(c(0,0)), st_point(c(1,1))))
```

- It is not entirely clear what the benefit is of having `typed` empty geometries, but according to the simple feature standard they are type so the `sf` package abides by that.

- Empty geometries can be detected by:

```{r}
st_is_empty(e)
```

## So:

  - There are 17 typed geometries supported by the simple feature standard
  - All geometries are made up of points
  - points can exist in 2,3,4 Dinimsonal space
  - `LINESTRING` and `POLYGON` geometries have rules that define validity
  - Geometries can be empty (but are still typed)

# Well-known Text, Well-known Binary

## WKT and WKB

The simple feature standard includes two encodings: 

Well-known text (WKT) & well-known binary (WKB) 

`Well Known Text` is human-readable:

```{r}
x <- st_linestring(matrix(10:1,5))
st_as_text(x)
```

In this example, 

The word `LINESTRING` provides the geometry *type* which is followed by a parentheses, inside the parentheses are the `points` that make up the geometry.

Separate points are separated by a "comma", while the point coordinates are separated by a "space."

Coordinates are usually floating point numbers, and moving large amounts of information as text is slow and imprecise. 

For that reason, we use well-known binary (WKB) encoding

```{r}
x
st_as_binary(x)
```

- Binary conversion is used to communicate geometries to external libraries (GDAL, GEOS, liblwgeom) and spatial databases because it is fast and lossless. 

- WKT and WKB can both be transformed back into R native objects by

```{r, message = TRUE}
st_as_sfc("LINESTRING(10 5, 9 4, 8 3, 7 2, 6 1)")[[1]]
st_as_sfc(structure(list(st_as_binary(x)), class = "WKB"))[[1]]
```

Conversion between R native objects and WKB is done by package `sf` in compiled (C++/Rcpp) code, making this a reusable and fast route for I/O of simple feature geometries in R.

## How simple features are organized in R?

- Simple Features is a standard that is implemented in R (not limited to R)

- So far we have discusses simple features the _standard_, rather then simple features the _implementation_

- In R, simple features are implemented using standard data *structures* (S3 classes, lists, matrix, vector).  

- Attributes are  stored in `data.frames` (or `tbl_df`)

- Feature geometries are stored in a `data.frame` column. 

- Since geometries are not single-valued, they are put in a `list-column`

- This means each observation (element) is a list itself!

Remember our nested lists?

```{r}
list(list(c(1:5)))
```
  
# sfg --> sfc --> sf

## sf, sfc, sfg

The three classes are used to represent simple feature obejcts are:

* `sf`: `data.frame` with feature attributes and geometries

which is composed of

* `sfc`: the `list-column` with the geometries for each feature

which is composed of

* `sfg`, individual simple feature geometries

## sf, sfc, sfg

```{r, echo = FALSE, out.width = "75%", fig.align="center"}
knitr::include_graphics("images/10-sf-diagram.png")
```

In the output we see:

* in green a simple feature: a single **record** (row, consisting of attributes and geometry
* in blue a single simple feature **geometry** (an object of class `sfg`)
* in red a simple feature list-column (an object of class `sfc`, which is a column in the `data.frame`)

Even though geometries are native R objects, they are printed as **well-known text**

## `sfg`: simple feature geometry (blue)

```{r, echo = FALSE, out.width = "35%", fig.align="center"}
knitr::include_graphics("images/10-sf-diagram.png")
```

- Simple feature geometry (`sfg`) objects carry the geometry for a single feature

- Simple feature geometries are implemented as R native data, using the following rules

  1. a single POINT is a numeric vector

  2. a set of points (e.g. in a LINESTRING or ring of a POLYGON) is a `matrix`, each row containing a point

  3. any other set is a `list`

    - list of numeric matrices for `MULTILINESTRING` and `POLYGON`
    - list of lists of numeric matrices for `MULTIPOLYGON`
    - list of (typed) geometries for `GEOMETRYCOLLECTION`

## `sfg`: simple feature geometry

Creator functions are **rarely** used in practice, since we typically read existing spatial data. But, they are useful for illustration:

```{r}
(x <- st_point(c(1,2)))
str(x)
(x <- st_linestring(matrix(c(1,2,3,4), ncol=2)))
str(x)
```

## `sfg`: simple feature geometry

All geometry objects have a S3 class indicating their (1) dimension, (2) type, and (3) superclass

```{r}
(pt = st_point(c(0,1)))
attributes(pt)

(pt2 = st_point(c(0,1,4)))
attributes(pt2)
```

## `sfg`: simple feature geometry

::: columns
::: {.column width="50%"}
```{r}
(m1 = rbind(c(8, 1), c(2, 5), c(3, 2)))

(mp = st_multipoint(m1))
attributes(mp)
```
:::
::: {.column width="50%"}
```{r}
(ls = st_linestring(m1))
attributes(ls)
```
:::
:::

## `sfg`: simple feature geometry

Although these geometries contain the same `points` (m1), they have entirely different meaning: the point set is a zero-dimensional, the line a one-dimensional geometry:

Here, dimensions is no the XY vs XYZ, but rather whether the geometry has length (1D) or area (2D) or greater...

```{r}
st_dimension(mp)
st_length(mp)
st_dimension(ls)
st_length(ls)
```

## GEOMETRYCOLLECTION 

- Single features can have a geometry that consists of several geometries of different types.

- Such cases arise rather naturally when looking for intersections. For instance, the intersection of two LINESTRING geometries may be the combination of a `LINESTRING` and a `POINT.` 

- Putting this intersection into a single feature geometry needs a `GEOMETRYCOLLECTION`

```{r}
pt <- st_point(c(1, 0))
ls <- st_linestring(matrix(c(4, 3, 0, 0), ncol = 2))
poly1 <- st_polygon(list(matrix(c(5.5, 7, 7, 6, 5.5, 0, 0, -0.5, -0.5, 0), ncol = 2)))
poly2 <- st_polygon(list(matrix(c(6.6, 8, 8, 7, 6.6, 1, 1, 1.5, 1.5, 1), ncol = 2)))
multipoly <- st_multipolygon(list(poly1, poly2))

(j <- st_geometrycollection(list(pt, ls, poly1, poly2, multipoly)))
```

- In case we end up with `GEOMETRYCOLLECTION` objects, the next question is often what to do with them. One thing we can do is extract elements from them:

```{r}
st_collection_extract(j, "POLYGON")

st_collection_extract(j, "POINT")

st_collection_extract(j, "LINESTRING")
```

# Conversion between geometry types

We can convert simple feature geometries using the `st_cast` generic (up to the extent that a conversion is feasible):

```{r}
methods(st_cast)
```

Lets take the Santa Barbara County in our California sf object:

```{r}
(co1 = co$geometry[[35]])
(co_ls = st_cast(co1, "MULTILINESTRING"))
```

```{r, echo = FALSE}
par(mfrow = c(1,2))
par(mar=c(1,1,1,1))
plot(co1, col = "red")
title("MULITPOLGYGON")
plot(co_ls, col = "red")
title("MULITLINESTRING")
```

It is often convenient to analyze the the points that make up a `LINESTRING` However,

```{r, warning=TRUE}
rbind(c(0,0), c(1,1), c(1,0), c(0,1)) |> 
  st_linestring() |> 
  st_cast("POINT")
```

does not what we expect, because it will convert a **single** geometry into a new **single** geometry (one line to one point)

Instead, we must recognize that a collection of points is what defines a `LINSETRING` and a collection of of `POINT`, operating as a single unit, is a `MULTIPOINT`

```{r}
rbind(c(0,0), c(1,1), c(1,0), c(0,1)) |> 
  st_linestring() |> 
  st_cast("MULTIPOINT")
```

If we really wanted the individual `POINT` geometries, we need to work with sets:

```{r}
(p <- rbind(c(0,0), c(1,1), c(1,0), c(0,1)) |> 
   st_linestring() |> 
   st_sfc() |> #<<
   st_cast("POINT"))
```

##  `sfc`: sets of geometries

- `sf` provides a dedicated class for handeling geometry sets, called `sfc` (simple feature geometry list column). 

- We can create such a list column with constructor function `st_sfc`:

```{r}
(sfc = st_sfc(st_point(c(0,1)), st_point(c(-3,2))))
```

The default report from the print method for sfc gives

- the number of features geometries
- the feature geometry type (here: POINT)
- the feature geometry dimension (here: XY)
- the bounding box for the set
- the coordinate reference system for the set (epsg and proj4string)
- the first few geometries, as (abbreviated) WKT

The class of the geometry `list-column` is a combination of a specific class, and a superclass. 

```{r}
class(sfc)
```

In addition to a class, the `sfc` object has further attributes (remember S3 class!)

```{r}
attributes(sfc) |> names()
```

which are used to record for the whole set:

- a precision value
- the bounding box enclosing all geometries (for x and y)
- a coordinate reference system
- the number of empty geometries contained in the set


This means that all these properties are defined for the set (sfc), and not for geometries (sfg) individually.

`sfc` objects are lists with each entry being an sfg object:

```{r}
p[[2]]
```

and we will use these lists as _list columns_ in `data.frame` or `tibble` objects to represent simple features with geometries in a list column.

`r flipbookr::chunq_reveal("set", title = "Sets of geometries arise when we separate compound geometries: ", widths = c(40,60,0))`

```{r set, include = FALSE, warning = TRUE}
rbind(c(0,0), c(1,1), c(1,0), c(0,1)) |>
   st_linestring() |> 
   st_sfc() |> 
   st_cast("POINT") -> 
  p


rbind(c(0,0), c(1,1), c(1,0), c(0,1)) |>
   st_linestring() |> 
   st_cast("POINT") 
```

- On the last slide, `st_sfc` creates a set of _one_ `LINESTRING` (p), with a size of 4.

- Going the other way around (from set to feature), we need to _combine_ geometries:

::: columns
::: {.column width="50%"}
```{r}
p
```
:::
::: {.column width="50%"}
```{r}
st_combine(p)
```
:::
:::

## Casting must be done the level of the feature

If we want to go from the 4 feature (p) object to a 1 feature LINESTRING, we must combine before casting ...

```{r}
st_combine(p) |> 
  st_cast("LINESTRING")
```

# Disolving Geometries 

Combining geometries **preserves** their interior boundaries, unioning **resolves/dissolves** the internal boundaries:

::: columns
::: {.column width="50%"}
```{r}
(co_geom = co$geometry)
```
:::
::: {.column width="50%"}
```{r}
plot(co_geom)
```
:::
:::

--- 

::: columns
::: {.column width="50%"}
```{r}
(co_c = st_combine(co_geom) )
(co_u = st_union(co_geom) )
```
:::
::: {.column width="50%"}
```{r}
(co_c_ml = st_combine(co_geom) |> 
   st_cast("MULTILINESTRING"))
(co_u_ml = st_union(co_geom)  |> 
    st_cast("MULTILINESTRING"))
```
:::
:::

```{r, echo = F, fig.align='center'}
par(mfrow = c(2,2))
par(mar=c(1,1,1,1))
plot(co_c, col = "red", main = "st_combine")
plot(co_u, col = "red", main = "st_union")
plot(co_c_ml, col = "red", main = "st_combine / st_cast")
plot(co_u_ml, col = "red", main = "st_union / st_cast")
```

## Mixed geometries

Sets of simple features also consist of features with heterogeneous geometries. In this case, the geometry type of the set is `GEOMETRY`:

::: columns
::: {.column width="50%"}
```{r}
(g = st_sfc(st_point(c(0,0)), 
            st_linestring(rbind(c(0,0), c(1,1)))))
```
:::
::: {.column width="50%"}

These set can be filtered by using `st_is`

```{r}
g |> st_is("LINESTRING")
```

or, when working with sf objects,

```{r}
# Note need of %>%
st_sf(g) %>%
  filter(st_is(., "LINESTRING"))
```

:::
:::

## `sf`: objects with simple features

Simple features `geometries` and feature `attributes` are put together in `sf` (simple feature) objects.  

```{r}
co
```

This `sf` object is of class

```{r}
class(co)
```

meaning it extends `data.frame`, but with a single list-column with geometries, which is held in the column named:

```{r}
attr(co, "sf_column")
```

---

## sfc: simple feature geometry list-column

The column in the `sf` `data.frame` that contains the geometries is a list, of class `sfc`.

We can retrieve the geometry list-column as we would any data.frame column (e.g. `ca$geometry`), or more generally with `st_geometry`:

```{r}
(co_geom <- st_geometry(co))
```

Geometries are printed in abbreviated form, but we can view a complete geometry by selecting it:

```{r}
co_geom[[1]]
```

---

## Reading and writing

As we've seen above, reading spatial data from an external file can be done via `sf`
  - reading data requires the "parser function" and the file path

```{r, eval = FALSE}
co <- st_read("data/co.shp")
```

we can suppress the output by adding argument `quiet=TRUE` or by using the otherwise nearly identical but more quiet

```{r, eval = TRUE}
ca <- read_sf("data/co.shp")
```

Writing takes place in the same fashion, using `st_write`:

```{r, eval = FALSE}
st_write(co, "data/co.shp")
```

or its quiet alternative that silently overwrites existing files by default,

```{r, eval = FALSE}
write_sf(co, "co.shp") # silently overwrites
```

---

## From Tables (e.g. CSV)

Spatial data can also be created from CSV and other flat files once it is in R:

```{r,message=FALSE}
(cities = readr::read_csv("../labs/data/uscities.csv") |> 
  select(city, state_name, county_name, population, lat, lng) )
```

---

To do this, you must specify the `X` and the `Y` coordinate columns as well as a CRS:

- A typical lat/long CRS is EPSG:4326

```{r}
(cities_sf = st_as_sf(cities, coords = c("lng", "lat"), crs = 4326))
```

## Data Manipulation

Since `sf` objects are `data.frames`, our `dplyr` verbs work!

Lets find the most populous city in each California county...

--- 

`r flipbookr::chunq_reveal("dplyr", title = "sf and dplyr", widths = c(40,60,0))`

```{r dplyr, include = FALSE}
cities_sf |> 
  filter(state_name == "Colorado") |> 
  group_by(county_name) |> 
  slice_max(population, n = 1) -> 
  co_cities
```

---

## Plotting

We've already seen that `ggplot()` is a powerful visualization tool:

--

The 5 steps we described for building a ggplot are:
  1. canvas
  2. layers (geoms)
  3. labels
  4. facets
  5. themes

--
  
spatial work in R is becoming so common that `ggplot()` comes with a sf geom (`geom_sf`)

---

`r flipbookr::chunq_reveal("ggplot", title = "##sf an ggplot", widths = c(60,40,0))`

```{r ggplot, include = FALSE}
ggplot() + 
  geom_sf(data = co, aes(fill = aland/1e10)) + 
  geom_sf(data = co_cities, aes(size = population/1e5), col = "red") + 
  theme_linedraw() + 
  labs(title = "California Counties: Land Area",
       size = "Population \n(100,000)",
       fill = "Acres \n(billions)")
```


## So far ...

We've discussed the *simple feature* standard

 1.  Geometries (type, dimension, and structure)
 
    - Empty, Valid, Simple
    
 2.  Encoding (WKT & WKB)
 
 3.  A set of operations

And the implementation of the **simple features** standard in R

  - _sfg_: a _single_ feature geometry

  - _sfc_: a _set_ of geometries (`sfg`) stored as a list

  - _sf_: a `sfc` list joined with a `data.frame` (attributes)

This R implementation is ideal/special because it achieves the simple feature abstract goal of:

> "_A simple feature is defined by the OpenGIS Abstract specification to have both **spatial** and **non-spatial** attributes..._"  - [standard](http://www.opengeospatial.org/standards/sfa).

The shapefile/GIS traditional GIS view does not do this and seperates geometry (shp), from projection (prj), from data (dbf) and relates them through an shx file
  
## Integration with `tidyverse`

- We saw how the `dplyr` verbs still work on an `sf` object since `sf` extends the data.frame class

- How `geom_sf` support mapping ("spatial plotting") in `ggplot`

- How to read spatial data into R via GDAL drivers:
  - spatial files (`read_sf`) 
  - flat files via `st_as_sf`
  
- Integration with a few `GEOS` geometry operations like:
  - st_combine()
  - st_union()

## Taki ...

::: {columns}
::: {.column width="50%"}

```{r}
conus <-  USAboundaries::us_states() |>
  filter(!state_name %in% c("Puerto Rico", 
                            "Alaska", 
                            "Hawaii"))

length(st_geometry(conus))
```

:::
::: {.column width="50%"}

```{r}
#| echo: false
ggplot() + 
  geom_sf(data = conus, aes(fill = state_name)) + 
  theme_linedraw() + 
  theme(legend.position = "none") + 
  labs(title = paste("CONUS:", length(st_geometry(conus)), "feature(s)") ) + 
  scale_fill_viridis_d()
```

:::
:::

## 1 feature: resoloved and combined:

::: {columns}
::: {.column width="50%"}

- st_cast / st_union work on `sfg`, `sfc`, and `sf` objects:

```{r}
us_c_ml = st_combine(conus) |>
  st_cast("MULTILINESTRING")
   
us_u_ml = st_union(conus) |>
  st_cast("MULTILINESTRING")
```

:::
::: {.column width="50%"}

```{r}
#| echo: false
#| 
g1 = ggplot() + 
  geom_sf(data = us_c_ml, color = "red") + 
  theme_linedraw() + 
  theme(legend.position = "none") + 
  labs(title = paste("CONUS:", length(st_geometry(us_c_ml)), "feature(s)") ) 

g2 = ggplot() + 
  geom_sf(data = us_u_ml, color = "red") + 
  theme_linedraw() + 
  theme(legend.position = "none") + 
  labs(title = paste("CONUS:", length(st_geometry(us_u_ml)), "feature(s)") ) 

gridExtra::grid.arrange(g1, g2, nrow = 1)

```
:::
:::

## So what?

Lets imagine we want to know the distance from Denver to the nearest state border:

To do this, we need to:\

  1: define Denver as a geometry in a CRS\
  2: determine the correct geometry types / representation\
  3: calculate the distance between (1) and (2)\

## 1. Make "Denver" in the CRS of our states

```{r}
denver = data.frame(y = 39.7392, x = -104.9903, name = "Denver")
(denver_sf = st_as_sf(denver, coords = c("x", "y"), crs = 4326))
```

`r flipbookr::chunq_reveal("q14", title = "2. Determine the 3 closest states:", lcolw = 40, rcolw = 60)`

```{r q14, include = FALSE}
conus |> 
  select(state_name) %>%
  mutate(dist = st_distance(., denver_sf)) |> 
  slice_min(dist, n = 3) 
```

- That's close, but the distance to Colorado is 0, that's not a state border.

##  Geometry Selection

- `Polygon` (therefore MULTIPOLGYGONS) describe areas! 
- The distance to a `point` **in** a `polygon` to that polygon is 0.

`r flipbookr::chunq_reveal("q15", title = "To determine distance to border we need a linear representation:", widths = c(40,60,0))`

```{r q15, include = FALSE}
conus |> 
  select(state_name) |> 
  st_cast("MULTILINESTRING") %>%
  mutate(dist = st_distance(., denver_sf)) |> 
  slice_min(dist, n = 3) ->
  near3
```

```{r, echo = FALSE}
near3
```

- Good. However, we were only interested in the distance to the closest border not to ALL boarders. Therefore we calculated 48 (49 - 1) more distances then needed!

- While this is not to complex for 1 <-> 49 features imagine we had 28,000+ (like) your lab!

- That would result in 1,344,000 more calculations then needed ...

## Revisting the idea of the feature level:

A "feature" can "be part of the whole" or the whole

  - A island (POLYGON), or a set of islands acting as 1 unit (MULTIPOLYGON)

  - A city (POINT), or a set of cities meeting a condition (MULTIPOINT)

  - A road (LINESTRING), or a route (MULTILINESTRING)
  
- Since we want the distance to the nearest border, _regardless_ of the state. Our **feature** is the _set of borders with preserved boundaries_.

- In other words, a 1 feature `MULTILINESTRING`

```{r}
st_distance(denver_sf, st_cast(st_combine(conus), "MULTILINESTRING"))
```

The same principle would apply if the question was "_distance to national border_"

## The stickness of `sfc` column

- A simple features object (sf) is the connection of a `sfc` list-column and `data.frame` of attributes

```{r}
#| echo: false
#| fig.align: 'center'
#| out.wisth: '75%'

knitr::include_graphics("images/11-sticky-geom.png")
```

- This binding is unique compared to other column bindings built with things like
    - `dplyr::bind_cols()`
    - `cbind()`
    - `do.call(cbind, list())`

## The stickness of `sfc` column

- Geometry columns are "sticky" meaning they persist through data manipulation:

```{r}
USAboundaries::us_states() |> 
  select(name) |> 
  slice(1:2)
```

Dropping the geometry column requires dropping the geometry via `sf`:

```{r}
USAboundaries::us_states() |> 
  st_drop_geometry() |> #<<
  select(name) |> 
  slice(1:2)
```

Or cohersing the `sf` object to a `data.frame`:

```{r}
USAboundaries::us_states() |> 
  as.data.frame() |> #<<
  select(name) |> 
  slice(1:2)
```

## Coordinate Systems

- What makes a feature geometry _spatial_ is the reference system...

```{r}
#| echo: false
#| fig.align: 'center'
#| out.wisth: '75%'
knitr::include_graphics("images/09-sf-model.png")
```

## Coordinate Systems

- Coordinate Reference Systems (CRS) defines how spatial features relate to the surface of the Earth. 

- CRSs are either geographic or projected...

- CRSs are measurement units for coordinates: 

## `sf` tools

In `sf` we have _three_ tools for exploring, define, and changing CRS systems:

  -  *st_crs* : Retrieve coordinate reference system from sf or sfc object

  -  *st_set_crs* : Set or replace coordinate reference system from object

  -  *st_transform* : Transform or convert coordinates of simple feature

- Again, "st" (like PostGIS) denotes it is an operation that can work on a " _s_ patial _t_ ype "  
  
## Geographic Coordinate Systms (GCS)

A GCS identifies locations on the _curved_ surface of the earth. 

Locations are measured in **angular** units from the center of the earth relative to the plane defined by the equator and the plane defined by the prime meridian. 

The vertical angle describes the _latitude_ and the horizontal angle the _longitude_

In most coordinate systems, the North-South and East-West directions are encoded as +/-.

North and East are positive (`+`) and South and West are negative (`-`) sign.

A GCS is defined by 3 components:

  - an **ellipsoid** 
  
  - a **geoid** 

  - a **datum**

## Sphere and Ellipsoid

- Assuming that the earth is a perfect sphere simplifies calculations and works for small-scale maps (maps that show a *large* area of the earth). 

- But ... the earth is not a sphere do to its rotation inducing a centripetal force along the equator. 

- This results in an equatorial axis that is roughly 21 km longer than the polar axis.

- To account for this, the earth is  modeled as an ellipsoid (slighty squished sphere) defined by two radii: 

  - the **semi-major** axis (along the equatorial radius) 
  - the **semi-minor** axis (along the polar radius)

```{r}
#| echo: false
#| fig.align: 'center'
#| out.width: '100%'

knitr::include_graphics("images/11-semi-axis.svg")
```

##

- Thanks to satellite and computational capabilities our estimates of these radii are be quite precise 

  - The semi-major axis is 6,378,137 m
  
  - The semi-minor axis is 6,356,752 m

- Differences in distance along the surfaces of an ellipsoid vs. a perfect sphere are small but measurable (the difference can be as high as 20 km)

::: {columns}
::: {.column width="50%"}
```{r}
#| echo: false
#| fig.align: 'center'
#| out.width: '100%'
knitr::include_graphics("images/11-sphere.svg")
```
:::
::: {.column width="50%"}
```{r}
#| echo: false
#| fig.align: 'center'
#| out.width: '100%'
knitr::include_graphics("images/11-ellipsoid.svg")
```
:::
:::

## Geoid

- The _ellipsoid_ gives us the earths form as a perfectly smooth object

- But ... the earth is not perfectly smooth

- Deviations from the perfect sphere are measurable and can influence measurements. 

- A *geoid* is a mathematical model fore representing these deviations

  - We are _not_ talking about mountains and ocean trenches but the earth's gravitational potential which is tied to the flow of the earth's hot and fluid core.
  
  - Therefore the geoid is constantly changing, albeit  a large temporal scale. 

- The measurement and representation of the earth's shape is at the heart of `geodesy`

```{r}
#| echo: false
#| fig.align: 'center'
#| fig.cap: "NASA's geoid models"
knitr::include_graphics("images/11-nasa-geoids.jpg")
```

## Datum

- So how are we to reconcile our need to work with a (simple) mathematical model of the earth's shape with the undulating nature of the geoid?

- We align the geoid with the ellipsoid to map the the earths departures from the smooth assumption

- The alignment can be **local** where the ellipsoid surface is closely fit to the geoid at a particular location on the earth's surface 

or 

- **geocentric** where the ellipsoid is aligned with the center of the earth. 


- The alignment of the smooth ellipsoid to the geoid model defines a **datum**. 

## Local Datums

- There are many local datums to choose from

- The choice of datum is largely driven by the location

- When working in the USA, a the North American Datum of 1927 (or NAD27 for short) is standard
  - NAD27 is not well suited for other parts of the world.

Examples of common local datums are shown in the following table:

##

|Local datum	     | Acronym | Best for|	Comment |
|------------------|---------|---------|---------|
| North American Datum of 1927 |	NAD27	| Continental US	| This is an old datum but still prevalent | because of the wide use of older maps. |
| European Datum of 1950	| ED50	| Western Europe |	Developed after World War II and still quite popular | today. Not used in the UK. |
| World Geodetic System 1972	| WGS72 |	Global |	Developed by the Department of Defense. |


## Geocentric Datum

- Many modern datums use a geocentric alignment 

  - World Geodetic Survey for 1984 (WGS84) 

  - North American Datums of 1983 (NAD83) 

- Most popular geocentric datums use the WGS84 _ellipsoid_ or the GRS80 _ellipsoid_  which share nearly identical semi-major and semi-minor axes

## 

|Geocentric datum| Acronym | Best for|	Comment |
----------------|---------|---------|--------- |
| North American Datum of 1983 |	NAD83	 | Continental US	| This is one of the most popular modern datums for the contiguous US. |
| European Terrestrial Reference System 1989 | ETRS89 |	Western Europe | This is the most popular modern datum for much of Europe. |
| World Geodetic System 1984 | WGS84 | Global | Developed by the Department of Defense. |

::: {.callout-note}
NAD 27 is based on Clarke Ellipsoid of 1866 which is calculated by manual surveying. NAD83 is based on the Geodetic Reference System (GRS) of 1980. 
:::

## Building a GCS

- So, a GCS is defined by the ellipsoid model and its alignment to the geoid defining the datum. 

- Smooth Sphere - Mathmatical Geoid (in angular units)


## Projected Coordinate Systems

- The surface of the earth is curved but maps (and to data GIS) is flat. 

- A projected coordinate system (PCS) is a reference system for identifying locations and measuring features on a flat (2D) surfaces. I

- Projected coordinate systems have an origin, an *x* axis, a *y* axis, and a linear unit of measure. 

- Going from a GCS to a PCS requires mathematical transformations. 

- There are three main groups of projection types:

  - conic
  - cylindrical
  - planar

## Projection Types:

```{r, echo = FALSE, out.width="50%", fig.align='center'}
knitr::include_graphics("images/11-projected-crs.png")
```

- In all cases, distortion is _minimized_ at the line/point of **tangency** (denoted by black line/point)

- Distortions are _minimized_ along the tangency lines and increase with the distance from those lines. 

## Plannar

- A planar projection projects data onto a flat surface touching the globe at a _point_ or along 1 line of _tangency._ 

- Typically used to map polar regions.

```{r, echo = FALSE, out.width="50%", fig.align='center'}
knitr::include_graphics("images/11-projected-crs.png")
```

## Cylindrical 

- A cylindrical projection maps the surface onto a cylinder. 

- This projection could also be created by touching the Earth’s surface along 1 or 2 lines of _tangency_ 

- Most often when mapping the entire world. 

```{r, echo = FALSE, out.width="50%", fig.align='center'}
knitr::include_graphics("images/11-projected-crs.png")
```

## Conic 

In a conic projection, the Earth’s surface is projected onto a cone along 1 or 2 lines of _tangency_ 

Therefore, it is the best suited for maps of mid-latitude areas. 

```{r, echo = FALSE, out.width="50%", fig.align='center'}
knitr::include_graphics("images/11-projected-crs.png")
```

## Spatial Properties

- All projections _distort_ real-world geographic features.

- Think about trying to unpeel an orange while preserving the skin

The four spatial properties that are subject to distortion are: **shape**, **area**, **distance** and **direction**

  - A map that preserves shape is called `conformal`; 
  
  - one that preserves area is called `equal-area`; 

  - one that preserves distance is called `equidistant`
  
  - one that preserves direction is called `azimuthal`

  - Each map projection can preserve only one or two of the four spatial properties. 

  - Often, projections are named after the spatial properties they preserve.

- When working with small-scale (large area) maps and when multiple spatial properties are needed, it is best to break the analyses across projections to minimize errors associated with spatial distortion.

## Setting CRSs/PCSs

 - We saw that `sfc` objects have two attributes to store a CRS: `epsg` and `proj4string`

```{r}
st_geometry(conus)
```

 - This implies that all geometries in a geometry list-column (sfc) must have the same CRS. 

- `proj4string` is a generic, string-based description of a CRS, understood by [PROJ](https://proj4.org/) 

- It defines projection types and parameter values for particular projections,

- As a result it can cover an infinite amount of different projections.  

- `epsg` is the _integer ID_ for a known CRS that can be resolved into a `proj4string`. 
  - This is somewhat equivalent to the idea that a 6-digit FIP code can be resolved to a state/county pair

- Some `proj4string` values can resolved back into their corresponding `epsg` ID, but this does not always work.

- The importance of having `epsg` values stored with data besides `proj4string` values is that the `epsg` refers to particular, well-known CRS, whose parameters may change (improve) over time

- fixing only the `proj4string` may remove the possibility to benefit from such improvements, and limit some of the provenance of datasets (but may help reproducibility)

## `PROJ4` coordinate syntax

The `PROJ4` syntax contains  a list of parameters, each prefixed with the `+` character. 

A list of some `PROJ4` parameters follows and the full list can be found [here](https://proj.org/usage/projections.html):

| Parameter      	| Description                             	|
|-	|-	|
| +a      	| Semi-major radius of the ellipsoid axis                              	|
| +b      	| Semi-minor radius of the ellipsoid axis                              	|
| +datum  	| Datum name                                                          	|
| +ellps  	| Ellipsoid name                                                      	|
| +lat_0  	| Latitude of origin                                                  	|
| +lat_1  	| Latitude of first standard parallel                                 	|
| +lat_2  	| Latitude of second standard parallel                                	|
| +lat_ts 	| Latitude of true scale                                              	|
| +lon_0  	| Central meridian                                                    	|
| +over   	| Allow longitude output outside -180 to 180 range, disables wrapping 	|
| +proj   	| Projection name                                                     	|
| +south  	| Denotes southern hemisphere UTM zone                                	|
| +units  	| meters, US survey feet, etc.                                        	|
| +x_0    	| False easting                                                       	|
| +y_0    	| False northing                                                      	|
| +zone   	| UTM zone                                                            	|

## 

**WGS84**  \
_EPSG_: 4326  \
_PROJ4_: `+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs`  \
  - projection name: longlat\
  - Latitude of origin: WGS84\
  - Longitude of origin: WGS84\

**WGS84**\
_EPSG_: 5070\
`"+proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs"`\
  - projection name: `aea` (Albers Equal Area)\
  - Latitude of origin: 23\
  - Longitude of origin: -96\
  - Latitude of first standard parallel: 29.5\
  - Latitude of second standard parallel: 45.5\
  - False Easting: 0\
  - False Northing: 0\
  - Datum: NAD83\
  - Units: m\
  
## Transform and retrive

::: {columns}
::: {.column width="50%"}
```{r}
st_crs(conus)$epsg
st_crs(conus)$proj4string
st_crs(conus)$datum
```
:::
::: {.column width="50%"}
```{r}
conus5070 <- st_transform(conus, 5070)

st_crs(conus5070)$epsg
st_crs(conus5070)$proj4string
st_crs(conus5070)$datum
```
:::
:::

```{r, echo = FALSE, out.width = "90%", fig.align='center'}
g1 = ggplot(data = conus) + 
  geom_sf() + 
  theme_linedraw()+ 
  coord_sf(datum = 4326) + 
  labs(title = "Unprojected CONUS",
       subtitle = "EPSG:4326")

g2 = ggplot(data =st_transform(conus, 5070)) + 
  geom_sf() +
  theme_linedraw()+ 
  coord_sf(datum = 5070) + 
  labs(title = "Projected CONUS",
       subtitle = "AEA") 

g3 = ggplot(data =st_transform(conus, '+proj=eqdc +lat_0=40 +lon_0=-96 +lat_1=20 +lat_2=60 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs')) + 
  geom_sf() +
  theme_linedraw()+ 
  coord_sf(datum = '+proj=eqdc +lat_0=40 +lon_0=-96 +lat_1=20 +lat_2=60 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs') + 
  labs(title = "Projected CONUS",
       subtitle = "EQDC") 

gridExtra::grid.arrange(g1, g2, g3, nrow =1) 
```

## Revisit Denver

```{bash}
echo -104.9903 39.7392 | proj +proj=eqdc +lat_0=40 +lon_0=-96 +lat_1=20 +lat_2=60 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs
```

- red = false origin : blue = Denver

```{r}
#| layout-ncol: 2
#| echo: false
#| out.width: '75%'
#| 
p = 5070
x = -762409.05	
y = 1893843.60 
ggplot(data =st_transform(conus, p)) + 
  geom_sf() +
  geom_segment(aes(x =0,  y= 0, xend = x, yend = y), lty = 2) +
  geom_segment(aes(x =x,  y= 0, xend = x, yend = y), lty = 2, col = "gray") +
  geom_segment(aes(x =0,  y= y, xend = x, yend = y), lty = 2, col = "gray") +
  geom_vline(xintercept = 0) + 
  geom_hline(yintercept = 0) +
  geom_point(aes(x = 0, y = 0 ), col = "red") +
  geom_point(aes(x = x, y = y), col = "blue")+
  theme_linedraw(18)+ 
  coord_sf(datum = p) + 
  labs(title = "Denver",
       subtitle = "AEA")  +
  ylim(c(-2000, 3.1e6)) 

p = '+proj=eqdc +lat_0=40 +lon_0=-96 +lat_1=20 +lat_2=60 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs'
x = -723281.88		
y = 6827.29   
  
ggplot(data =st_transform(conus, p)) + 
  geom_sf() +
  geom_segment(aes(x =0,  y= 0, xend = x, yend = y), lty = 2) +
  geom_segment(aes(x =x,  y= 0, xend = x, yend = y), lty = 2, col = "gray") +
  geom_segment(aes(x =0,  y= y, xend = x, yend = y), lty = 2, col = "gray") +
  geom_vline(xintercept = 0) + 
  geom_hline(yintercept = 0) +
  geom_point(aes(x = 0, y = 0 ), col = "red") +
  geom_point(aes(x = x, y = y), col = "blue")+
  theme_linedraw(18)+ 
  coord_sf(datum = p) + 
  labs(title = "Denver",
       subtitle = "EQDC")  
```

## Geodesic geometries

- PCSs introduce errors in their geometric measurements because the distance between two points on an ellipsoid is difficult to replicate on a projected coordinate system unless these points are close to one another.

- In most cases, such errors other sources of error in the feature representation outweigh measurement errors made in a PCS making them tolorable.

However, if the domain of analysis is large (i.e. the North American continent), then the measurement errors associated with a projected coordinate system may no longer be acceptable. 

A way to circumvent projected coordinate system limitations is to adopt a _geodesic_ solution.

## Geodesic Measurments

- A **geodesic distance** is the shortest distance between two points on an ellipsoid

- A **geodesic area** measurement is one that is measured on an ellipsoid. 

- Such measurements are _independent_ of the underlying projected coordinate system. 

- Why does this matter? 

- Compare the distances measured between Santa Barbara and Amsterdam. The blue line represents the shortest distance between the two points on a *planar* coordinate system. The red line as measured on a *ellipsoid*.

```{r}
#| fig-height: 12
#| fig-width: 24
#| echo: false

library(tmap)
library(geosphere)
library(sp)
library(maps)
library(sf)
# Define a few CRS
w.from.s <- "+proj=ortho +lat_0=60 +lon_0=-28 +x_0=0 +y_0=0 +a=6370997 +b=6370997 +units=m +no_defs"
latlon   <- "+proj=longlat +datum=WGS84"
# Define extent for first map
ext <- tmaptools::bb(matrix(c(-130, 10, 90,90)), projection="+proj=longlat +datum=WGS84")
# Define point locations
sb <- c(-105.0844,  40.5853)
ams <- c(4.8945, 52.3667)
pt <- st_as_sf(data.frame(rbind(sb, ams)), coords=c("X1", "X2"), crs = 4326)
# Compute great circle line segment
gc <- gcIntermediate(sb, ams)
# Create sf object from gci matrix
gc_sf <- as_tibble(gc) |> 
  mutate(id =1) |> 
  st_as_sf(coords = c("lon","lat"), crs = 4326) |> 
  group_by(id) |> 
  summarise(do_union=TRUE) |> 
  st_cast("MULTILINESTRING") |> 
  st_line_merge()

# Create planar line segment for comparison
pl_sf <- data.frame(rbind(sb, ams)) |>   
             mutate(id =1) |> 
             st_as_sf(coords = c("X1","X2"), crs = 4326) |> 
             group_by(id) |> 
             summarise(do_union=TRUE) |> 
             st_cast("LINESTRING") |> 
             as('Spatial') |>   # Convert to sp object
             spsample(n=100, type="regular") |>  # densify by creating points
             st_as_sf() |> # Convert back to sf
             mutate(id=1) |> 
             group_by(id) |> 
             summarise(do_union=TRUE) |> 
             st_cast("LINESTRING")
# Create a rasterized world layer

sf::sf_use_s2(FALSE)

World <- st_transform(st_as_sf((rnaturalearth::countries110)), crs="+proj=longlat +datum=WGS84") |> 
  st_union() |> 
  st_as_sf()

r     <- raster::raster(ncol=1500, nrow=800)
wrld  <- fasterize::fasterize(World, r)
# Reproject data
wrld2 <- raster::projectRaster(wrld, crs= w.from.s )
# Plot on a planar environment
tm_shape(wrld, bbox=ext) + 
  tm_raster(legend.show = FALSE, palette= c("grey80")) +
  tm_graticules(col="grey90", labels.col="white")+
  tm_shape(gc_sf) +
  tm_lines(col="red", lwd=4) +
  tm_shape(pl_sf) + 
  tm_lines(col="blue", lwd=4) +
  tm_shape(pt) +
  tm_dots(size=0.5) 
```

##

- the geodesic distance looks weird given its curved appearance on the projected map. 

- this curvature is a byproduct of the current reference system’s increasing distance distortion as one moves towards the pole! 
- We can display the geodesic and planar distance on a 3D globe (or a projection that mimics the view of the 3D earth).

```{r  fig.width=9,echo=FALSE, fig.align='center'}
tm_shape(wrld2) +
  tm_raster(legend.show = FALSE, palette= c("grey80")) +
  tm_graticules(col="grey90", labels.col="white")+
  tm_shape(gc_sf) +
  tm_lines(col="red", lwd=2) +
  tm_shape(pl_sf) + 
  tm_lines(col="blue", lwd=2, lty=2) +
  tm_shape(pt) +tm_dots(size=0.5) 
```

## 

- So if a geodesic measurement is more precise than a planar measurement, why not perform all spatial operations using geodesic geometry? 

- The downside is in its computational requirements. 

- It's far more efficient to compute area/distance on a plane than it is on a spheroid. 

- This is because geodesic calculations have no simple algebraic solutions and involve approximations that may require iteration! (think optimization or nonlinear solutions) 

- So this may be a computationally taxing approach if processing 1,000(s) or 1,000,000(s) of line segments. 

## Gedesic Area and Length Measurements

- Not all algorthimns are equal (in terms of speed or accuracy)

- Some more efficient algorithms that minimize computation time may reduce precision in the process. 

- Some of ArcMap’s functions offer the option to compute geodesic distances and areas however ArcMap does not clearly indicate _how_ its geodesic calculations are implemented ([cite](https://mgimond.github.io/Spatial/coordinate-systems.html#geodesic-geometries) 

- R is well documented, and is efficient!

## Distances

`?st_distance`

```{r, fig.align='center', out.width="75%", echo = FALSE}
knitr::include_graphics("images/11-sf-geos-measures.png")
```

## native `sf` binds to `libwgeom`

::: {columns}
::: {.column width="50%"}
```{r, fig.align='center', out.width="75%", echo = FALSE}
knitr::include_graphics("images/11-lwgeom.png")
```
:::
::: {.column width="50%"}
```{r, fig.align='center', out.width="75%", echo = FALSE}
knitr::include_graphics("images/09-sf-depends.png")
```
:::
:::

`r flipbookr::chunq_reveal("dist1", title = "Distance Example", widths = c(40,60,0))`

```{r dist1, include = FALSE}
(pts = data.frame(y = c(40.7128, 34.4208), 
                  x = c(-74.0060, -119.6982 ), 
                  name = c("NYC","SB")))

(pts = st_as_sf(pts, coords = c("x", "y"), crs = 4326))

eqds = '+proj=eqdc +lat_0=40 +lon_0=-96 +lat_1=20 +lat_2=60 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs'

# Greeat Circle Distance
st_distance(pts)

# Euclidean Distance
st_distance(pts, which = "Euclidean")

# Equal Area PCS
st_distance(st_transform(pts, 5070))

# Equal Distance
st_distance(st_transform(pts, eqds))

```

`r flipbookr::chunq_reveal("conus", title = "Area Example: CONUS", widths = c(40,60,0))`

```{r conus, include = FALSE}
us_u_mp = st_cast(us_u_ml, "MULTIPOLYGON")

df = data.frame(name = c("WGS84", "AEA", "EPDS"),
           area = c(sum(st_area(conus)), 
            sum(st_area(st_transform(conus, 5070))),
            sum(st_area(st_transform(conus, eqds)))))

ggplot(df) +
  geom_col(aes(x = name, y = as.numeric(area) )) + 
  theme_linedraw() + 
  labs(x = "SRS", y = "m2")
```


## Units in `sf`

- The CRS in `sf` encodes the units of measurement relating to spatial features

- Where possible geometric operations such as `st_distance()`, `st_length()` and `st_area()` report results with a units attribute appropriate for the CRS:

- This can be both handy and very confusing for those new to it. Consider the following:

```{r}
(l = sum(st_length(conus)))
(a = sum(st_area(conus)))
```

## 

We can set units if we do manipulations as well using the units package
```{r}
units::set_units(l, "km")
units::set_units(l, "mile")

units::set_units(a, "ha")
units::set_units(a, "km2")
units::set_units(a, "in2")
```

## Units are a class 

- units are an S3 data object with attribute information and "rules of engagement"

```{r, error = TRUE}
class(st_length(conus)) 
attributes(st_length(conus)) |> unlist()

st_length(conus) + 100

conus |> 
  mutate(area = st_area(.)) |> 
  ggplot(aes(x = name, y = area)) + 
  geom_col()
```

## Unit values can be stripped of their attributes if need be:

```{r}
# Via drop_units
(units::drop_units(sum(st_length(conus))))

# Via casting
(as.numeric(sum(st_length(conus))))
```


